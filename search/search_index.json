{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"S03-smart-contracts/M2-intro-to-truffle/L1-background/","text":"Introduction to Truffle Suite Before we go into the Solidity section, we want to make sure you have a place where you can play around with the Solidity code you're starting to learn. Enter the Truffle Suite! Truffle is an excellent tool to learn Solidity development but, as we'll show later in the course, it's also got advanced features. Don't be deceived by how easy it is! History and Evolution As with any emergent ecosystem, tooling in the early days of EVM-based dapp development was somewhat primitive. Developers were required to install and utilize multiple, disjointed tools and services making for a complex workflow with a steep learning curve. Things have come a long way since then, with tools and services like Codefi, Infura, Metamask, and OpenZeppelin Contracts that simplify a significant number of smart contract software development lifecycle stages. Despite these advancements, there are still numerous pitfalls, particularly related to the security of your contracts, which makes web3 development different to what you might be used to when building against a more centralized paradigms. Why Truffle Suite? The Truffle Suite was built to streamline the smart contract development process. Out of the box it includes a large, and growing, collection of commands that you can execute as you write, troubleshoot, and maintain your smart contracts. A good example of this is contract compilation (wherein you convert your high-level contract code to something that can be natively understood by an Ethereum-node). As part of this feature, Truffle can also intelligently download the necessary compiler version(s) and even enable you to write your contracts in different language versions. Additional reasons why developers might Truffle to build their dapps include the following... Built-in support for compiling, deploying and linking your contract An automated contract testing framework built on Mocha and Chai A built-in console that allows you to directly interact with your compiled contracts This is just scratching the surface; as you\u2019ll see when we dive-in, the Truffle Suite and the broader tooling ecosystem makes your life as a dapp developer both productive and fun! Installation The following walks you through installation of both Truffle CLI and Ganache. Truffle CLI The Truffle Suite requires the following... Node.js v8.9.4 or later NPM v5.0.3 or later Windows, Linux or Mac OS X Truffle also requires that you have a running Ethereum client which supports the standard JSON RPC API (which is nearly all of them). While there are many clients, the Truffle Suite also ships with Ganache, essentially a one-click EVM-based blockchain node for local testing. Once you have the proper Node and npm installed, please run the following command from your terminal to install Truffle: $ npm install -g truffle Once succesful, this will allow you to run Truffle from your command line anywhere on your machine. Ganache Ganache has the same requirements as Truffle (as specified above). In addition, it also comes in two flavors, both a standalone CLI for more intermediate-advanced users and a UI version which is great for users that are just starting out. It\u2019s worth noting that a version of Ganache also ships directly with Truffle which can be instantiated with the truffle develop command. Ganache CLI can be installed via the following: $ npm install -g ganache-cli Ganache UI is available as download here. You can also install the latest beta (at the time of writing) that includes Filecoin support here. Congratulations! You've just successfully installed Truffle and Ganache and are ready to get started developing. Introducing the Truffle Suite Now that we have Truffle (and optionally a standalone Ganache version) installed we\u2019re nearly ready to begin diving in and writing our first smart contract. We'd like to cover a few more things before diving in. Network Support As we discussed previously in the course, we are living in an increasingly multi-chain world. There multiple popular public blockchain networks and Truffle Suite aims to serve as many of these as is realistic. At the time of writing, Truffle Suite supports development on the following networks: Ethereum Quorum Hyperledger Fabric Corda Filecoin Tezos Polygon Arbritrum Optimism PBC That said, Truffle\u2019s richest support is for that of EVM (Ethereum Virtual Machine) based blockchains. This is in part due to Truffle\u2019s lineage and the fact that supporting every blockchain would be futile, particularly given the rapid evolution of the space. Given the above, the bulk of this section of the course will be specifically focused on EVM based chains (unless specified otherwise). Language Support As highlighted earlier, amongst many other things, Truffle handles the compilation of your contracts from that of a higher-level language to Ethereum bytecode, which is the language \u201cspoken\u201d by the nodes on the network. Out of the box, Truffle supports the following: Solidity Vyper Yul (experimental and not for beginners) At the time of writing, Solidity is by far the most popular language for writing smart contracts, although as with everything in the space, things are moving rapidly and it\u2019s recently there\u2019s been some major projects built using Vyper. Core Truffle Commands Truffle is built around a large collection of commands that you use as part of your contract development workflow. Examples of these include: truffle init truffle compile truffle test truffle debug truffle migrate Note that you can see a complete list of the available commands by running truffle help . As you can likely infer from the commands, they map to key stages of the development lifecycle. More on this in the upcoming section! Truffle Boxes Truffle also provides Boxes, or pre-built templates and Truffle codebases that allow you to focus on either learning more about smart contract development or building quickly. In addition to Truffle code, Truffle Boxes can contain other helpful modules, Solidity contracts & libraries, front-end views and more; all the way up to complete example dapps. We'll discuss boxes more when we dive deeper into developer tooling and more advanced Truffle, but feel free to explore available boxes. Two popular boxes to for folks new to Truffle are Petshop and Metacoin. In the next section, we'll take a simple smart contract and use it to explore the initial commands for developing using Truffle.","title":"Index"},{"location":"S03-smart-contracts/M2-intro-to-truffle/L1-background/#introduction-to-truffle-suite","text":"Before we go into the Solidity section, we want to make sure you have a place where you can play around with the Solidity code you're starting to learn. Enter the Truffle Suite! Truffle is an excellent tool to learn Solidity development but, as we'll show later in the course, it's also got advanced features. Don't be deceived by how easy it is!","title":"Introduction to Truffle Suite"},{"location":"S03-smart-contracts/M2-intro-to-truffle/L1-background/#history-and-evolution","text":"As with any emergent ecosystem, tooling in the early days of EVM-based dapp development was somewhat primitive. Developers were required to install and utilize multiple, disjointed tools and services making for a complex workflow with a steep learning curve. Things have come a long way since then, with tools and services like Codefi, Infura, Metamask, and OpenZeppelin Contracts that simplify a significant number of smart contract software development lifecycle stages. Despite these advancements, there are still numerous pitfalls, particularly related to the security of your contracts, which makes web3 development different to what you might be used to when building against a more centralized paradigms.","title":"History and Evolution"},{"location":"S03-smart-contracts/M2-intro-to-truffle/L1-background/#why-truffle-suite","text":"The Truffle Suite was built to streamline the smart contract development process. Out of the box it includes a large, and growing, collection of commands that you can execute as you write, troubleshoot, and maintain your smart contracts. A good example of this is contract compilation (wherein you convert your high-level contract code to something that can be natively understood by an Ethereum-node). As part of this feature, Truffle can also intelligently download the necessary compiler version(s) and even enable you to write your contracts in different language versions. Additional reasons why developers might Truffle to build their dapps include the following... Built-in support for compiling, deploying and linking your contract An automated contract testing framework built on Mocha and Chai A built-in console that allows you to directly interact with your compiled contracts This is just scratching the surface; as you\u2019ll see when we dive-in, the Truffle Suite and the broader tooling ecosystem makes your life as a dapp developer both productive and fun!","title":"Why Truffle Suite?"},{"location":"S03-smart-contracts/M2-intro-to-truffle/L1-background/#installation","text":"The following walks you through installation of both Truffle CLI and Ganache. Truffle CLI The Truffle Suite requires the following... Node.js v8.9.4 or later NPM v5.0.3 or later Windows, Linux or Mac OS X Truffle also requires that you have a running Ethereum client which supports the standard JSON RPC API (which is nearly all of them). While there are many clients, the Truffle Suite also ships with Ganache, essentially a one-click EVM-based blockchain node for local testing. Once you have the proper Node and npm installed, please run the following command from your terminal to install Truffle: $ npm install -g truffle Once succesful, this will allow you to run Truffle from your command line anywhere on your machine.","title":"Installation"},{"location":"S03-smart-contracts/M2-intro-to-truffle/L1-background/#ganache","text":"Ganache has the same requirements as Truffle (as specified above). In addition, it also comes in two flavors, both a standalone CLI for more intermediate-advanced users and a UI version which is great for users that are just starting out. It\u2019s worth noting that a version of Ganache also ships directly with Truffle which can be instantiated with the truffle develop command. Ganache CLI can be installed via the following: $ npm install -g ganache-cli Ganache UI is available as download here. You can also install the latest beta (at the time of writing) that includes Filecoin support here. Congratulations! You've just successfully installed Truffle and Ganache and are ready to get started developing.","title":"Ganache"},{"location":"S03-smart-contracts/M2-intro-to-truffle/L1-background/#introducing-the-truffle-suite","text":"Now that we have Truffle (and optionally a standalone Ganache version) installed we\u2019re nearly ready to begin diving in and writing our first smart contract. We'd like to cover a few more things before diving in.","title":"Introducing the Truffle Suite"},{"location":"S03-smart-contracts/M2-intro-to-truffle/L1-background/#network-support","text":"As we discussed previously in the course, we are living in an increasingly multi-chain world. There multiple popular public blockchain networks and Truffle Suite aims to serve as many of these as is realistic. At the time of writing, Truffle Suite supports development on the following networks: Ethereum Quorum Hyperledger Fabric Corda Filecoin Tezos Polygon Arbritrum Optimism PBC That said, Truffle\u2019s richest support is for that of EVM (Ethereum Virtual Machine) based blockchains. This is in part due to Truffle\u2019s lineage and the fact that supporting every blockchain would be futile, particularly given the rapid evolution of the space. Given the above, the bulk of this section of the course will be specifically focused on EVM based chains (unless specified otherwise).","title":"Network Support"},{"location":"S03-smart-contracts/M2-intro-to-truffle/L1-background/#language-support","text":"As highlighted earlier, amongst many other things, Truffle handles the compilation of your contracts from that of a higher-level language to Ethereum bytecode, which is the language \u201cspoken\u201d by the nodes on the network. Out of the box, Truffle supports the following: Solidity Vyper Yul (experimental and not for beginners) At the time of writing, Solidity is by far the most popular language for writing smart contracts, although as with everything in the space, things are moving rapidly and it\u2019s recently there\u2019s been some major projects built using Vyper.","title":"Language Support"},{"location":"S03-smart-contracts/M2-intro-to-truffle/L1-background/#core-truffle-commands","text":"Truffle is built around a large collection of commands that you use as part of your contract development workflow. Examples of these include: truffle init truffle compile truffle test truffle debug truffle migrate Note that you can see a complete list of the available commands by running truffle help . As you can likely infer from the commands, they map to key stages of the development lifecycle. More on this in the upcoming section!","title":"Core Truffle Commands"},{"location":"S03-smart-contracts/M2-intro-to-truffle/L1-background/#truffle-boxes","text":"Truffle also provides Boxes, or pre-built templates and Truffle codebases that allow you to focus on either learning more about smart contract development or building quickly. In addition to Truffle code, Truffle Boxes can contain other helpful modules, Solidity contracts & libraries, front-end views and more; all the way up to complete example dapps. We'll discuss boxes more when we dive deeper into developer tooling and more advanced Truffle, but feel free to explore available boxes. Two popular boxes to for folks new to Truffle are Petshop and Metacoin. In the next section, we'll take a simple smart contract and use it to explore the initial commands for developing using Truffle.","title":"Truffle Boxes"},{"location":"S03-smart-contracts/M4-design-patterns/L4-oracles/","text":"Oracles In our discussion blockchain primitives, we discussed how public blockchain networks coordinate these powerful tools to create a network state that can be established and maintained by network participants. However, that network state only holds true within the boundaries of the network itself. We can only guarantee the state transitions of the network participants running our blockchain client software. What about data that exists outside this network, specifically what about \"real world\" data, such as weather reports, incident details or stock prices? Such data exists but they are beyond the trust boundary established by our blockchain protocols. One way blockchain developers have tried to bridge the gap is through what are called off-chain oracles. Off-chain oracles are agents that find and verify real-world information and submit them to the blockchain to be used by smart contracts. They can trigger smart contract executions when the data is obtained or predefined conditions are meet (e.g. time, weather, tracking, payments). Off-chain oracles are provided by organizations like Provable Things, Chainlink Labs, and more. Please note that DeFi has led to on-chain oracles, particularly dealing with token prices, which we will discuss more in the section on DeFi. Such examples of on-chain oracles are Uniswap's [Observations](https://docs.uniswap.org/protocol/concepts/V3-overview/oracle){target=_blank} and MakerDAO's Feeds Trust It's extremely important to understand oracles like the ones we're discussing here require trust and they should only be used when the information isn't available in the blockchain. They should be used only when necessary and only from sources you understand. When using oracles, it's important to build in smart contract mechanisms that can anticipate errors or possible corruption. Oracles can succumb to many attack vectors. Services such as Chainlink have built more decentralized networks to hedge against the centralization of trust, you can read more about how Chainlink does that here and see an overview of decentralized oracles here. Basic Oracle Mechanism At its most basic, a smart contract contract using an oracle needs to implement a method to: Make the request to the oracle, and Receive the oracle's response from a callback method Unless you've setup the service yourself, external calls to oracles typically require a fee attached to provide the data to your contract. There are multiple ways to achieve this, let's look at one generalized code using Provable below: import \"github.com/oraclize/ethereum-api/provableAPI.sol\"; contract DieselPrice is usingProvable { uint DieselPriceUSD; constructor() public { provable_query(\"URL\", \"xml(https://www.fueleconomy.gov/ws/rest/fuelprices).fuelPrices.diesel\"); } function __callback (bytes32 myid, string result) public { require(msg.sender == provable_cbAddress()); DieselPriceUSD = parseInt(result); } } In this code, we're calling the Provable API for the price of diesel when we create the contract. The first query is free, but we'll have to provide ETH to pay for our requests moving forward. The call triggers an event, which lets the Provable contract pull from its off-chain datafeed and provide our contract the result. The contract stores that value in DieselPriceUSD . The overall model is for your contract to emit an event, either to another contract or simply in the block its created. The oracle service will detect that event, pull the desired data, and respond back to your contract. The oracle services require you to have a standard method, like __callback , that its transaction can target when responding to your oracle query. The oracle ecosystem is growing as fast as blockchain, and we'll touch on it more later in the course. For now, it's important to see how oracles allow us to cross the \"trust boundary\" of blockchains, what trust assumptions that requires, and the basic design pattern for incorporating this data stream. Additional Material Wiki: Oracles (Ethereum.org) A great overview of oracles on Ethereum with demo code for Chainlink Wikipedia: Blockchain Oracle Docs: Chainlink A really well-curated series of docs outline how to get started with Chainlink and the different services and networks available. Tutorial: Implementing a Blockchain Oracle on Ethereum * Code: Provable Things Ethereum Examples A collection of examples from Provable Things, a bit dated but can still provide a source of reference. * Academic Article: A Study of Blockchain Oracles A technical examination of blockchain oracles referenced in the blockchain oracles Wikipedia page. * Article: So You Want to Use a Price Oracle Interesting article (albeit about on-chain oracles) discussing attack vectors.","title":"Oracles"},{"location":"S03-smart-contracts/M4-design-patterns/L4-oracles/#oracles","text":"In our discussion blockchain primitives, we discussed how public blockchain networks coordinate these powerful tools to create a network state that can be established and maintained by network participants. However, that network state only holds true within the boundaries of the network itself. We can only guarantee the state transitions of the network participants running our blockchain client software. What about data that exists outside this network, specifically what about \"real world\" data, such as weather reports, incident details or stock prices? Such data exists but they are beyond the trust boundary established by our blockchain protocols. One way blockchain developers have tried to bridge the gap is through what are called off-chain oracles. Off-chain oracles are agents that find and verify real-world information and submit them to the blockchain to be used by smart contracts. They can trigger smart contract executions when the data is obtained or predefined conditions are meet (e.g. time, weather, tracking, payments). Off-chain oracles are provided by organizations like Provable Things, Chainlink Labs, and more. Please note that DeFi has led to on-chain oracles, particularly dealing with token prices, which we will discuss more in the section on DeFi. Such examples of on-chain oracles are Uniswap's [Observations](https://docs.uniswap.org/protocol/concepts/V3-overview/oracle){target=_blank} and MakerDAO's Feeds","title":"Oracles"},{"location":"S03-smart-contracts/M4-design-patterns/L4-oracles/#trust","text":"It's extremely important to understand oracles like the ones we're discussing here require trust and they should only be used when the information isn't available in the blockchain. They should be used only when necessary and only from sources you understand. When using oracles, it's important to build in smart contract mechanisms that can anticipate errors or possible corruption. Oracles can succumb to many attack vectors. Services such as Chainlink have built more decentralized networks to hedge against the centralization of trust, you can read more about how Chainlink does that here and see an overview of decentralized oracles here.","title":"Trust"},{"location":"S03-smart-contracts/M4-design-patterns/L4-oracles/#basic-oracle-mechanism","text":"At its most basic, a smart contract contract using an oracle needs to implement a method to: Make the request to the oracle, and Receive the oracle's response from a callback method Unless you've setup the service yourself, external calls to oracles typically require a fee attached to provide the data to your contract. There are multiple ways to achieve this, let's look at one generalized code using Provable below: import \"github.com/oraclize/ethereum-api/provableAPI.sol\"; contract DieselPrice is usingProvable { uint DieselPriceUSD; constructor() public { provable_query(\"URL\", \"xml(https://www.fueleconomy.gov/ws/rest/fuelprices).fuelPrices.diesel\"); } function __callback (bytes32 myid, string result) public { require(msg.sender == provable_cbAddress()); DieselPriceUSD = parseInt(result); } } In this code, we're calling the Provable API for the price of diesel when we create the contract. The first query is free, but we'll have to provide ETH to pay for our requests moving forward. The call triggers an event, which lets the Provable contract pull from its off-chain datafeed and provide our contract the result. The contract stores that value in DieselPriceUSD . The overall model is for your contract to emit an event, either to another contract or simply in the block its created. The oracle service will detect that event, pull the desired data, and respond back to your contract. The oracle services require you to have a standard method, like __callback , that its transaction can target when responding to your oracle query. The oracle ecosystem is growing as fast as blockchain, and we'll touch on it more later in the course. For now, it's important to see how oracles allow us to cross the \"trust boundary\" of blockchains, what trust assumptions that requires, and the basic design pattern for incorporating this data stream.","title":"Basic Oracle Mechanism"},{"location":"S03-smart-contracts/M4-design-patterns/L4-oracles/#additional-material","text":"Wiki: Oracles (Ethereum.org) A great overview of oracles on Ethereum with demo code for Chainlink Wikipedia: Blockchain Oracle Docs: Chainlink A really well-curated series of docs outline how to get started with Chainlink and the different services and networks available. Tutorial: Implementing a Blockchain Oracle on Ethereum * Code: Provable Things Ethereum Examples A collection of examples from Provable Things, a bit dated but can still provide a source of reference. * Academic Article: A Study of Blockchain Oracles A technical examination of blockchain oracles referenced in the blockchain oracles Wikipedia page. * Article: So You Want to Use a Price Oracle Interesting article (albeit about on-chain oracles) discussing attack vectors.","title":"Additional Material"},{"location":"S04-developer-tooling/M1-intro/L4-ag-dev-workflow/","text":"Blockchain Agnostic Developer Workflow It's no surprise by now that, in this course, we want to give you frameworks to help you approach the complicated business of blockchain development. In this section, we're hoping to give you a sense of the general workflow you'll be doing as a developer while developing a distributed application (\"dapp\" or smart contract + interface) on any blockchain. Note: This is not the workflow of a protocol designer, which is a more traditional project-based work environment based on the development language Lifecycle of a Project Let's see the overall lifecycle of a dapp project: Perhaps the most important work you can do as a developer is the first step: Determine the scope and goals of your project. This does not require any code at all, but it will save you so much time in the future. It's essentially creating the roadmap for your application and, when things get complicated, you'll be able to refer back to it for clarity. (This step should be familiar as the first exercise in the course was for you to do this step for your final project!) Next comes the Architectural and Technical Design : Sketching out the technical parameters of your project. What will your smart contract function parameters look like? Where will you do storage? How will you divide on-chain and off-chain logic? If your project involves others, how will you implement governance? How do you plan to scale? Next is the Development phase, which is typically what people think the only phase. Please note that this is the third step in building a project (Planning is so important)! We'll drill deeper into this step later in the section, but it's primarily the building and testing of your smart contract and interface. In this step, you'll leverage framework development tools, like Truffle or Hardhat, as well as testing tools, like testing suites and testnets. You'll also be referring to the notes you've made in the previous two steps, being sure to stay within the guidelines you made for yourself. Next comes Security Audit. We've already heard about Diligence and security tools such as MythX, Scribble, Slither or Manticore. For projects that could potentially hold enormous value this step is critical and should not be overlooked. It can sometimes be challenging to find a team or project to audit your code, but it is worth the effort considering the potential downside! Simultaneous with an audit, you might be running the next step, Bug Bounty and Community, meaning somehow starting to ask your community to test-drive your project. Note, this is before an official, version 1.0 release. Last, after all these steps, is the Launch . You may have already stealthily deployed your contract, assuming you've done all the testing and auditing, but this is where you announce the interface and let folks know that it's ready to go! As we'll see next, in some ways your work has just begun, but at least you've gotten your project launched into the world! Developmer Tooling We're now going to drill into the Development phase mentioned above. This is probably what we all think of when we think about developing application for the blockchain. Here's a simplified oveview of what a development flow looks like at the beginning of a project: Here we see the developer (you) working mainly from their code editor, in which they'll have both the smart contracts and whatever frontend interface they're working on. The code editor will be stocked with the most helpful general extensions as well as specific smart contract extensions, such as the Solidity extension for VSCode as well as tools to help with gas estimation or contract sizing. Next, the developer will have a framework that they're using to deploy the smart contract and interface. In the image above, the developer is using Truffle to build their contracts, hold the build artifacts, run tests and deploy to a testnet. There are other options as well, such as Hardhat , Scaffold-Eth , and Brownie , to name some of the more popular ones. The developer will then having some private testnet tool they're using to deploy the smart contract in the early stages. This will be Ganache for us, since we're using Truffle. As we continue to become more confident in our development process, we may want to deploy to a public testnet. For this, we will use either an Ethereum node we have on our machine or we'll use a gateway service like Infura , which will allow us to easily deploy to an Ethereum testnet, Ethereum mainnet, or even networks like Polygon, Arbitrum or Optimism. (If we're starting to lose you, don't worry we'll cover all these things later in the course!) .env File One thing that seems trivial but is incredibly important is the .env file for your project. These are the local environmental variables that allow you to deploy your application to the public blockchain network. It also is the best way to ensure you don't expose your private keys or any other sensitive information when you're developing. Particularly when you're pushing material to a git repository, it's easy for folks to forget they've included sensitive information. There are definitely bots that are continually scanning Github for private keys that will immediately be compromised. Please read this article about how to keep your development environment safe by using a .env file and other essential techniques! Advanced Developer Tooling As you become more familiar with blockchain development and as your project grows, so will your toolset and workflow. Below is a diagram showing a more expansive development lifecycle that includes auditing, scaling, monitoring and advanced onboarding of users: (We're using ConsenSys products here mainly for reference, since we've discussed many of them so far.) We'll get into these tools more but it's a bit beyond the scope of this lesson. In the next few sections, however, you'll become more familiar with the tools and mechanisms shown here. Additional Materials Remix Interface The original IDE for Ethereum! Well, probably not the original, but still the best first place to go to start Solidity development. Basic Training: Code Editors, VSCode Extensions I know, I know, you're super sick of hearing about Basic Training. Fair! But you should be sure to install all the VSCode extensions in this section of Basic Training, since it will help with development! Tutorial: Using an .env file to keep your secrets safe Essential reading! Good Extensions to Know About Hardhat-contract-sizer , hardhat-gas-reporter Replit Still exploring this one, but really good potential for troubleshooting code with friends. Not blockchain specific! Testing in the Twenties Really good general advice about testing! How to Setup a Solidity Project","title":"Blockchain Agnostic Developer Workflow"},{"location":"S04-developer-tooling/M1-intro/L4-ag-dev-workflow/#blockchain-agnostic-developer-workflow","text":"It's no surprise by now that, in this course, we want to give you frameworks to help you approach the complicated business of blockchain development. In this section, we're hoping to give you a sense of the general workflow you'll be doing as a developer while developing a distributed application (\"dapp\" or smart contract + interface) on any blockchain. Note: This is not the workflow of a protocol designer, which is a more traditional project-based work environment based on the development language","title":"Blockchain Agnostic Developer Workflow"},{"location":"S04-developer-tooling/M1-intro/L4-ag-dev-workflow/#lifecycle-of-a-project","text":"Let's see the overall lifecycle of a dapp project: Perhaps the most important work you can do as a developer is the first step: Determine the scope and goals of your project. This does not require any code at all, but it will save you so much time in the future. It's essentially creating the roadmap for your application and, when things get complicated, you'll be able to refer back to it for clarity. (This step should be familiar as the first exercise in the course was for you to do this step for your final project!) Next comes the Architectural and Technical Design : Sketching out the technical parameters of your project. What will your smart contract function parameters look like? Where will you do storage? How will you divide on-chain and off-chain logic? If your project involves others, how will you implement governance? How do you plan to scale? Next is the Development phase, which is typically what people think the only phase. Please note that this is the third step in building a project (Planning is so important)! We'll drill deeper into this step later in the section, but it's primarily the building and testing of your smart contract and interface. In this step, you'll leverage framework development tools, like Truffle or Hardhat, as well as testing tools, like testing suites and testnets. You'll also be referring to the notes you've made in the previous two steps, being sure to stay within the guidelines you made for yourself. Next comes Security Audit. We've already heard about Diligence and security tools such as MythX, Scribble, Slither or Manticore. For projects that could potentially hold enormous value this step is critical and should not be overlooked. It can sometimes be challenging to find a team or project to audit your code, but it is worth the effort considering the potential downside! Simultaneous with an audit, you might be running the next step, Bug Bounty and Community, meaning somehow starting to ask your community to test-drive your project. Note, this is before an official, version 1.0 release. Last, after all these steps, is the Launch . You may have already stealthily deployed your contract, assuming you've done all the testing and auditing, but this is where you announce the interface and let folks know that it's ready to go! As we'll see next, in some ways your work has just begun, but at least you've gotten your project launched into the world!","title":"Lifecycle of a Project"},{"location":"S04-developer-tooling/M1-intro/L4-ag-dev-workflow/#developmer-tooling","text":"We're now going to drill into the Development phase mentioned above. This is probably what we all think of when we think about developing application for the blockchain. Here's a simplified oveview of what a development flow looks like at the beginning of a project: Here we see the developer (you) working mainly from their code editor, in which they'll have both the smart contracts and whatever frontend interface they're working on. The code editor will be stocked with the most helpful general extensions as well as specific smart contract extensions, such as the Solidity extension for VSCode as well as tools to help with gas estimation or contract sizing. Next, the developer will have a framework that they're using to deploy the smart contract and interface. In the image above, the developer is using Truffle to build their contracts, hold the build artifacts, run tests and deploy to a testnet. There are other options as well, such as Hardhat , Scaffold-Eth , and Brownie , to name some of the more popular ones. The developer will then having some private testnet tool they're using to deploy the smart contract in the early stages. This will be Ganache for us, since we're using Truffle. As we continue to become more confident in our development process, we may want to deploy to a public testnet. For this, we will use either an Ethereum node we have on our machine or we'll use a gateway service like Infura , which will allow us to easily deploy to an Ethereum testnet, Ethereum mainnet, or even networks like Polygon, Arbitrum or Optimism. (If we're starting to lose you, don't worry we'll cover all these things later in the course!)","title":"Developmer Tooling"},{"location":"S04-developer-tooling/M1-intro/L4-ag-dev-workflow/#env-file","text":"One thing that seems trivial but is incredibly important is the .env file for your project. These are the local environmental variables that allow you to deploy your application to the public blockchain network. It also is the best way to ensure you don't expose your private keys or any other sensitive information when you're developing. Particularly when you're pushing material to a git repository, it's easy for folks to forget they've included sensitive information. There are definitely bots that are continually scanning Github for private keys that will immediately be compromised. Please read this article about how to keep your development environment safe by using a .env file and other essential techniques!","title":".env File"},{"location":"S04-developer-tooling/M1-intro/L4-ag-dev-workflow/#advanced-developer-tooling","text":"As you become more familiar with blockchain development and as your project grows, so will your toolset and workflow. Below is a diagram showing a more expansive development lifecycle that includes auditing, scaling, monitoring and advanced onboarding of users: (We're using ConsenSys products here mainly for reference, since we've discussed many of them so far.) We'll get into these tools more but it's a bit beyond the scope of this lesson. In the next few sections, however, you'll become more familiar with the tools and mechanisms shown here.","title":"Advanced Developer Tooling"},{"location":"S04-developer-tooling/M1-intro/L4-ag-dev-workflow/#additional-materials","text":"Remix Interface The original IDE for Ethereum! Well, probably not the original, but still the best first place to go to start Solidity development. Basic Training: Code Editors, VSCode Extensions I know, I know, you're super sick of hearing about Basic Training. Fair! But you should be sure to install all the VSCode extensions in this section of Basic Training, since it will help with development! Tutorial: Using an .env file to keep your secrets safe Essential reading! Good Extensions to Know About Hardhat-contract-sizer , hardhat-gas-reporter Replit Still exploring this one, but really good potential for troubleshooting code with friends. Not blockchain specific! Testing in the Twenties Really good general advice about testing! How to Setup a Solidity Project","title":"Additional Materials"},{"location":"S04-developer-tooling/M2-web3-libraries/L1-intro-web3-ethers/","text":"Web 3 Javascript Libraries As we mentioned in \"Where Do Users Fit in Our Mental Model?\" Web 3 Javascript APIs are critical to connecting users to our blockchain applications. There are a variety of common JavaScript libraries that you can use to connect to Ethereum and develop an interface for your users. Many of the libraries serve the same purpose and have the same functionality, but the syntax differs for each. The purpose of this lesson is to show the similarities and differences between the main two libraries, Web3.js and ethers.js, so you gain a better understanding of what these libraries do a general level and how each one does it. If you are using the Brave browser, you may encounter conflicts with the built-in Ethereum wallet and Metamask. If this happens, try using a different browser with Metamask installed. Truffle Truffle is the framework that we have covered in the most depth so far in the course. Truffle will connect to a running blockchain specified in the truffle-config.js file, manage deployments via migration scripts and information stored in the truffle artifacts and abstracts away much of the complexity of interacting with contracts (via contract abstractions ). Other libraries handle these in different ways and have different APIs that are useful to review. Web3.js Web3.js is one of the most popular JavaScript libraries in Ethereum dApp development. Unfortunately there are two versions of web3.js in use right now. Web3.js 1.x is in development, you can visit the documentation for 1.x here . The latest stable version at the time of this writing is web3.js 0.2x.x, and you can see those docs here . As you can see, the APIs for these versions are different, so pay attention to which version you are using. Web3.js is the library that is injected by Metamask. If you have Metamask installed in your browser, you can see the web3 object by opening your browser developer tools (ctrl shift i in Chrome) and typing web3 in the console. As you go through this workshop, if you encounter problems, try refreshing your browser and repeating the necessary steps. You can see the current version is \"0.20.x\", in the \"version\" property of the web3 object. This web3 object is connected to the Ethereum network through a service provided by Metamask. Metamask uses Infura infrastructure as the gateway to Ethereum. We have included a version of the newer web3.js API in the page as well, so by entering web3 = new Web3(web3.currentProvider) in the browser console, you can get an instance of the web3.js version 1.x. For the remainder of this lesson, we will be using the web3.js v1.x beta API . A Side note about Metamask If you are following along in your browser, you will also see that in the \"currentProvider\" property, the \"selectedAddress\" is undefined or null. Metamask does not provide access to the account address by default. If you type ethereum.enable() in the console, Metamask will pop open asking you if you'd like to connect. Connecting will make this account information accessible to the current page. Connect to Ganache GUI Let's connect to Ganache GUI and send a transaction via the API in the console. Start Ganache GUI and connect Metamask (Ganache GUI defaults to port 7545). Use the Ganache GUI \"Quickstart\" option to follow along with the same account addresses that I use in this explanation. To connect to Ganache GUI, click \"Custom RPC\" in the Network drop down and then enter the network information. You can easily import Ganache GUI accounts into Metamask by importing via the private key. Click the key icon on the right side of Ganache GUI to get the associated account private key. To import the account into Metamask, select \"Import Account\" in the Metamask accounts dropdown, and paste in the private key. Checking the account Once you are connected to Ganache GUI through Metamask, you can send transactions on the Ganache GUI network through the injected web3 object in the browser console. Typing web3.currentProvider.selectedAddress should return your current account address. Sending a Transaction Use the following code snippet as your transaction information. var transaction = { from: web3.currentProvider.selectedAddress, to: \"0xce573835eB9ca38454f97D103Ca46b7e8aDF617f\", value: web3.utils.toWei(\"1\", \"ether\") } Th \"to\" account is the second account that is generated by the Quickstart in Ganache GUI. In the console, it look like this: Now sending a transaction is as easy as entering web3.eth.sendTransaction(transaction) in the console and Metamask will pop up, asking you to sign the transaction. If you get an error, you may need to reset the web3 provider. You can do that with this line of code web3.setProvider(web3.currentProvider) . Nonce Mismatch Errors If you use Metamask accounts on different development blockchains, the nonce counts may get out of sync, in which case you will see an error when trying to execute a transaction. Metamask tracks the account nonce independently so this can get out of sync with the account nonce on the blockchain network that you are trying to interact with. If this happens, it is a simple fix. Open Metamask and click the account icon on the upper right and select \"Settings\". In the \"Advanced\" area, select \"Reset Account\". If you were seeing this error, reset your account and try sending the transaction again. Metamask will get the correct account nonce from the blockchain network. When the transaction succeeds, you should see the new account balances reflected on Ganache GUI. You can check the balance of these accounts with the line await web3.eth.getBalance(address) where address is any Ethereum address. Try it with \" await web3.eth.getBalance(web3.currentProvider.selectedAddress) \". This is just a quick intro to sending transaction with web3.js v1.0. You can learn more about how to use it via the docs and specifically about how to connect to a contract via this section. Keep in mind that this library is still in development, so if you run into any bugs, please report them! Ethers.js Let's try connecting to a different library. The ethers.js library is also included on this page and is accessible via the browser JavaScript console. We will continue to use Metamask as the account signer for the accounts on the development blockchain. Connect to the Web 3 provider In the browser console, you can connect ethers.js to the current network by accessing the provider given by Metamask, then set it is as the \"signer\". Metamask injects the provider as \"web3.currentProvider\", but since we changed the web3 object to use web3.js v1.0, the provider is accessible at \"web3.givenProvider\". // MetaMask injects a Web3 Provider as \"web3.currentProvider\", so // we can wrap it up in the ethers.js Web3Provider, which wraps a // Web3 Provider and exposes the ethers.js Provider API. const provider = new ethers.providers.Web3Provider(web3.currentProvider); // There is only ever up to one account in MetaMask exposed const signer = provider.getSigner(); Now that Metamask is set as the signer, you can send a transaction. Check the \"signer\" API of ethers.js to see how to send a transaction. Something like \"signer.sendTransaction(transaction)\" should work, but what does a transaction look like in ethers.js? { // Required unless deploying a contract (in which case omit) to: addressOrName, // the target address or ENS name // These are optional/meaningless for call and estimateGas nonce: 0, // the transaction nonce gasLimit: 0, // the maximum gas this transaction may spend gasPrice: 0, // the price (in wei) per unit of gas // These are always optional (but for call, data is usually specified) data: \"0x\", // extra data for the transaction, or input for call value: 0, // the amount (in wei) this transaction is sending chainId: 3 // the network ID; usually added by a signer } You can check the docs here. For a simple ether transfer, you can get away with: var transaction = { to: \"0xce573835eB9ca38454f97D103Ca46b7e8aDF617f\", value: ethers.utils.parseEther(\"1\") } And to send it, enter signer.sendTransaction(transaction) in the browser console. Confirm the transaction and verify that the account balances have changed in Ganache GUI. Please explore the Ether.js documentation to see all of the things that it can do. Summary As a developer, you can use different JavaScript libraries to interact with Ethereum blockchains. Many of the JavaScript libraries do many of the same things, but they may handle transaction signers or providers differently or have different ways of connecting to contracts and listening to events. The library you choose is primarily a matter of personal preference. We focus on using web3.js in this course, but introduce ethers.js because it is a popular alternative. Additional Material Article: Web3 vs ethers Part I and Part II by Academy's own Tom Hay and Robbie K. Course: Learn Ethers.js (Chainshot) Use Chainshot's excellent interactive interface to learn more about ethers.js","title":"Web 3 Javascript Libraries"},{"location":"S04-developer-tooling/M2-web3-libraries/L1-intro-web3-ethers/#web-3-javascript-libraries","text":"As we mentioned in \"Where Do Users Fit in Our Mental Model?\" Web 3 Javascript APIs are critical to connecting users to our blockchain applications. There are a variety of common JavaScript libraries that you can use to connect to Ethereum and develop an interface for your users. Many of the libraries serve the same purpose and have the same functionality, but the syntax differs for each. The purpose of this lesson is to show the similarities and differences between the main two libraries, Web3.js and ethers.js, so you gain a better understanding of what these libraries do a general level and how each one does it. If you are using the Brave browser, you may encounter conflicts with the built-in Ethereum wallet and Metamask. If this happens, try using a different browser with Metamask installed.","title":"Web 3 Javascript Libraries"},{"location":"S04-developer-tooling/M2-web3-libraries/L1-intro-web3-ethers/#truffle","text":"Truffle is the framework that we have covered in the most depth so far in the course. Truffle will connect to a running blockchain specified in the truffle-config.js file, manage deployments via migration scripts and information stored in the truffle artifacts and abstracts away much of the complexity of interacting with contracts (via contract abstractions ). Other libraries handle these in different ways and have different APIs that are useful to review.","title":"Truffle"},{"location":"S04-developer-tooling/M2-web3-libraries/L1-intro-web3-ethers/#web3js","text":"Web3.js is one of the most popular JavaScript libraries in Ethereum dApp development. Unfortunately there are two versions of web3.js in use right now. Web3.js 1.x is in development, you can visit the documentation for 1.x here . The latest stable version at the time of this writing is web3.js 0.2x.x, and you can see those docs here . As you can see, the APIs for these versions are different, so pay attention to which version you are using. Web3.js is the library that is injected by Metamask. If you have Metamask installed in your browser, you can see the web3 object by opening your browser developer tools (ctrl shift i in Chrome) and typing web3 in the console. As you go through this workshop, if you encounter problems, try refreshing your browser and repeating the necessary steps. You can see the current version is \"0.20.x\", in the \"version\" property of the web3 object. This web3 object is connected to the Ethereum network through a service provided by Metamask. Metamask uses Infura infrastructure as the gateway to Ethereum. We have included a version of the newer web3.js API in the page as well, so by entering web3 = new Web3(web3.currentProvider) in the browser console, you can get an instance of the web3.js version 1.x. For the remainder of this lesson, we will be using the web3.js v1.x beta API .","title":"Web3.js"},{"location":"S04-developer-tooling/M2-web3-libraries/L1-intro-web3-ethers/#a-side-note-about-metamask","text":"If you are following along in your browser, you will also see that in the \"currentProvider\" property, the \"selectedAddress\" is undefined or null. Metamask does not provide access to the account address by default. If you type ethereum.enable() in the console, Metamask will pop open asking you if you'd like to connect. Connecting will make this account information accessible to the current page. Connect to Ganache GUI Let's connect to Ganache GUI and send a transaction via the API in the console. Start Ganache GUI and connect Metamask (Ganache GUI defaults to port 7545). Use the Ganache GUI \"Quickstart\" option to follow along with the same account addresses that I use in this explanation. To connect to Ganache GUI, click \"Custom RPC\" in the Network drop down and then enter the network information. You can easily import Ganache GUI accounts into Metamask by importing via the private key. Click the key icon on the right side of Ganache GUI to get the associated account private key. To import the account into Metamask, select \"Import Account\" in the Metamask accounts dropdown, and paste in the private key.","title":"A Side note about Metamask"},{"location":"S04-developer-tooling/M2-web3-libraries/L1-intro-web3-ethers/#checking-the-account","text":"Once you are connected to Ganache GUI through Metamask, you can send transactions on the Ganache GUI network through the injected web3 object in the browser console. Typing web3.currentProvider.selectedAddress should return your current account address.","title":"Checking the account"},{"location":"S04-developer-tooling/M2-web3-libraries/L1-intro-web3-ethers/#_1","text":"","title":""},{"location":"S04-developer-tooling/M2-web3-libraries/L1-intro-web3-ethers/#sending-a-transaction","text":"Use the following code snippet as your transaction information. var transaction = { from: web3.currentProvider.selectedAddress, to: \"0xce573835eB9ca38454f97D103Ca46b7e8aDF617f\", value: web3.utils.toWei(\"1\", \"ether\") } Th \"to\" account is the second account that is generated by the Quickstart in Ganache GUI. In the console, it look like this: Now sending a transaction is as easy as entering web3.eth.sendTransaction(transaction) in the console and Metamask will pop up, asking you to sign the transaction. If you get an error, you may need to reset the web3 provider. You can do that with this line of code web3.setProvider(web3.currentProvider) .","title":"Sending a Transaction"},{"location":"S04-developer-tooling/M2-web3-libraries/L1-intro-web3-ethers/#nonce-mismatch-errors","text":"If you use Metamask accounts on different development blockchains, the nonce counts may get out of sync, in which case you will see an error when trying to execute a transaction. Metamask tracks the account nonce independently so this can get out of sync with the account nonce on the blockchain network that you are trying to interact with. If this happens, it is a simple fix. Open Metamask and click the account icon on the upper right and select \"Settings\". In the \"Advanced\" area, select \"Reset Account\". If you were seeing this error, reset your account and try sending the transaction again. Metamask will get the correct account nonce from the blockchain network. When the transaction succeeds, you should see the new account balances reflected on Ganache GUI. You can check the balance of these accounts with the line await web3.eth.getBalance(address) where address is any Ethereum address. Try it with \" await web3.eth.getBalance(web3.currentProvider.selectedAddress) \". This is just a quick intro to sending transaction with web3.js v1.0. You can learn more about how to use it via the docs and specifically about how to connect to a contract via this section. Keep in mind that this library is still in development, so if you run into any bugs, please report them!","title":"Nonce Mismatch Errors"},{"location":"S04-developer-tooling/M2-web3-libraries/L1-intro-web3-ethers/#ethersjs","text":"Let's try connecting to a different library. The ethers.js library is also included on this page and is accessible via the browser JavaScript console. We will continue to use Metamask as the account signer for the accounts on the development blockchain.","title":"Ethers.js"},{"location":"S04-developer-tooling/M2-web3-libraries/L1-intro-web3-ethers/#connect-to-the-web-3-provider","text":"In the browser console, you can connect ethers.js to the current network by accessing the provider given by Metamask, then set it is as the \"signer\". Metamask injects the provider as \"web3.currentProvider\", but since we changed the web3 object to use web3.js v1.0, the provider is accessible at \"web3.givenProvider\". // MetaMask injects a Web3 Provider as \"web3.currentProvider\", so // we can wrap it up in the ethers.js Web3Provider, which wraps a // Web3 Provider and exposes the ethers.js Provider API. const provider = new ethers.providers.Web3Provider(web3.currentProvider); // There is only ever up to one account in MetaMask exposed const signer = provider.getSigner(); Now that Metamask is set as the signer, you can send a transaction. Check the \"signer\" API of ethers.js to see how to send a transaction. Something like \"signer.sendTransaction(transaction)\" should work, but what does a transaction look like in ethers.js? { // Required unless deploying a contract (in which case omit) to: addressOrName, // the target address or ENS name // These are optional/meaningless for call and estimateGas nonce: 0, // the transaction nonce gasLimit: 0, // the maximum gas this transaction may spend gasPrice: 0, // the price (in wei) per unit of gas // These are always optional (but for call, data is usually specified) data: \"0x\", // extra data for the transaction, or input for call value: 0, // the amount (in wei) this transaction is sending chainId: 3 // the network ID; usually added by a signer } You can check the docs here. For a simple ether transfer, you can get away with: var transaction = { to: \"0xce573835eB9ca38454f97D103Ca46b7e8aDF617f\", value: ethers.utils.parseEther(\"1\") } And to send it, enter signer.sendTransaction(transaction) in the browser console. Confirm the transaction and verify that the account balances have changed in Ganache GUI. Please explore the Ether.js documentation to see all of the things that it can do.","title":"Connect to the Web 3 provider"},{"location":"S04-developer-tooling/M2-web3-libraries/L1-intro-web3-ethers/#summary","text":"As a developer, you can use different JavaScript libraries to interact with Ethereum blockchains. Many of the JavaScript libraries do many of the same things, but they may handle transaction signers or providers differently or have different ways of connecting to contracts and listening to events. The library you choose is primarily a matter of personal preference. We focus on using web3.js in this course, but introduce ethers.js because it is a popular alternative.","title":"Summary"},{"location":"S04-developer-tooling/M2-web3-libraries/L1-intro-web3-ethers/#additional-material","text":"Article: Web3 vs ethers Part I and Part II by Academy's own Tom Hay and Robbie K. Course: Learn Ethers.js (Chainshot) Use Chainshot's excellent interactive interface to learn more about ethers.js","title":"Additional Material"},{"location":"S04-developer-tooling/M2-web3-libraries/L2-web3-connect-to-contract/","text":"This lesson is meant to directly follow the previous lesson. If you have not gone through that lesson yet, please go back and do that one first to avoid confusion and potential errors. In this lesson we are going to use web3.js in the browser console again. This time to connect to a SimpleStorage.sol contract that is deployed on the Rinkeby testnet. You can view the code for the contract on GitHub here and on etherscan here . Connect to the network First, make sure that Metamask is connected to the Rinkeby network. To use the web3.js 1.x library, we need to initialize it again. We can do that by running web3 = new Web3(web3.givenProvider) in the browser console. Initialize the contract Before we can interact with the contract, we need to initialize an instance of the SimpleStorage contract using web3.js. In this step we are going to provide web3.js with the ABI and the contract address, so it knows what functions are available at the address that we provide. The SimpleStorage.sol contract is deployed at address 0x49Bb098E781eD5C50D85E82d85cbA1a6F03FD3e6. Let's set the address in the console: const SSaddress = \"0x49Bb098E781eD5C50D85E82d85cbA1a6F03FD3e6\" Let's set the ABI in the console with: const ABI = [ { \"constant\": false, \"inputs\": [ { \"internalType\": \"uint256\", \"name\": \"x\", \"type\": \"uint256\" } ], \"name\": \"set\", \"outputs\": [], \"payable\": false, \"stateMutability\": \"nonpayable\", \"type\": \"function\" }, { \"anonymous\": false, \"inputs\": [ { \"indexed\": false, \"internalType\": \"uint256\", \"name\": \"newValue\", \"type\": \"uint256\" }, { \"indexed\": false, \"internalType\": \"address\", \"name\": \"updatedBy\", \"type\": \"address\" } ], \"name\": \"storageUpdate\", \"type\": \"event\" }, { \"constant\": true, \"inputs\": [], \"name\": \"get\", \"outputs\": [ { \"internalType\": \"uint256\", \"name\": \"\", \"type\": \"uint256\" } ], \"payable\": false, \"stateMutability\": \"view\", \"type\": \"function\" } ] To create a new contract instance we run const simpleStorage = new web3.eth.Contract(ABI, SSaddress) . We can see that the simpleStorage contract object now has events, methods and an address that we provided with the ABI and contract address. We just need to set the web3 provider for the contract, which we can do with simpleStorage.setProvider(web3.givenProvider) . Now we can use this contract object to interact with the deployed contract. You will need some Rinkeby ETH to pay for gas to interact with the contract. You can get some via this link: https://www.rinkeby.io/#faucet . Read the contract state Let's read the current value of the storedData. Since our contract object is saved as simpleStorage, run simpleStorage.methods.get().call().then(console.log) . This will print the current storedData value of the contract. Since this is just reading the contract, there is no transaction sent to the network and there is no cost associated with this action. Update the contract state We update the contract by sending it a transaction to the \"set()\" function with the desired parameter. This action does cost gas, since we need to update the state of the contract on all of the network nodes. Feel free to update the value to whatever you want. simpleStorage.methods.set(3).send({from: web3.givenProvider.selectedAddress}) Running this code should trigger Metamask to ask you to sign a transaction. Once the transaction is mined, you can check for the transaction with simpleStorage.methods.get().call().then(console.log) or you can check the contract on a Rinkeby block explorer like rinkeby.etherscan.io. https://rinkeby.etherscan.io/address/0x49bb098e781ed5c50d85e82d85cba1a6f03fd3e6 Watch for events You can easily subscribe to events with simpleStorage. Notice we have a \"storageUpdate\" event in the contract. To listen for that event, run simpleStorage.events.storageUpdate(function(error, event){console.log(event)}) Here is a link to the relevant web3.js documentation for subscribing to events. To trigger this event, you will have to call the \"set()\" function on the contract again. Once the update transaction is mined, the event will fire. This is what it looks like in the browser console. This should give you a good overview of how to connect to a contract and interact with it using web3.js","title":"Index"},{"location":"S04-developer-tooling/M2-web3-libraries/L2-web3-connect-to-contract/#connect-to-the-network","text":"First, make sure that Metamask is connected to the Rinkeby network. To use the web3.js 1.x library, we need to initialize it again. We can do that by running web3 = new Web3(web3.givenProvider) in the browser console.","title":"Connect to the network"},{"location":"S04-developer-tooling/M2-web3-libraries/L2-web3-connect-to-contract/#initialize-the-contract","text":"Before we can interact with the contract, we need to initialize an instance of the SimpleStorage contract using web3.js. In this step we are going to provide web3.js with the ABI and the contract address, so it knows what functions are available at the address that we provide. The SimpleStorage.sol contract is deployed at address 0x49Bb098E781eD5C50D85E82d85cbA1a6F03FD3e6. Let's set the address in the console: const SSaddress = \"0x49Bb098E781eD5C50D85E82d85cbA1a6F03FD3e6\" Let's set the ABI in the console with: const ABI = [ { \"constant\": false, \"inputs\": [ { \"internalType\": \"uint256\", \"name\": \"x\", \"type\": \"uint256\" } ], \"name\": \"set\", \"outputs\": [], \"payable\": false, \"stateMutability\": \"nonpayable\", \"type\": \"function\" }, { \"anonymous\": false, \"inputs\": [ { \"indexed\": false, \"internalType\": \"uint256\", \"name\": \"newValue\", \"type\": \"uint256\" }, { \"indexed\": false, \"internalType\": \"address\", \"name\": \"updatedBy\", \"type\": \"address\" } ], \"name\": \"storageUpdate\", \"type\": \"event\" }, { \"constant\": true, \"inputs\": [], \"name\": \"get\", \"outputs\": [ { \"internalType\": \"uint256\", \"name\": \"\", \"type\": \"uint256\" } ], \"payable\": false, \"stateMutability\": \"view\", \"type\": \"function\" } ] To create a new contract instance we run const simpleStorage = new web3.eth.Contract(ABI, SSaddress) . We can see that the simpleStorage contract object now has events, methods and an address that we provided with the ABI and contract address. We just need to set the web3 provider for the contract, which we can do with simpleStorage.setProvider(web3.givenProvider) . Now we can use this contract object to interact with the deployed contract. You will need some Rinkeby ETH to pay for gas to interact with the contract. You can get some via this link: https://www.rinkeby.io/#faucet .","title":"Initialize the contract"},{"location":"S04-developer-tooling/M2-web3-libraries/L2-web3-connect-to-contract/#read-the-contract-state","text":"Let's read the current value of the storedData. Since our contract object is saved as simpleStorage, run simpleStorage.methods.get().call().then(console.log) . This will print the current storedData value of the contract. Since this is just reading the contract, there is no transaction sent to the network and there is no cost associated with this action.","title":"Read the contract state"},{"location":"S04-developer-tooling/M2-web3-libraries/L2-web3-connect-to-contract/#update-the-contract-state","text":"We update the contract by sending it a transaction to the \"set()\" function with the desired parameter. This action does cost gas, since we need to update the state of the contract on all of the network nodes. Feel free to update the value to whatever you want. simpleStorage.methods.set(3).send({from: web3.givenProvider.selectedAddress}) Running this code should trigger Metamask to ask you to sign a transaction. Once the transaction is mined, you can check for the transaction with simpleStorage.methods.get().call().then(console.log) or you can check the contract on a Rinkeby block explorer like rinkeby.etherscan.io. https://rinkeby.etherscan.io/address/0x49bb098e781ed5c50d85e82d85cba1a6f03fd3e6","title":"Update the contract state"},{"location":"S04-developer-tooling/M2-web3-libraries/L2-web3-connect-to-contract/#watch-for-events","text":"You can easily subscribe to events with simpleStorage. Notice we have a \"storageUpdate\" event in the contract. To listen for that event, run simpleStorage.events.storageUpdate(function(error, event){console.log(event)}) Here is a link to the relevant web3.js documentation for subscribing to events. To trigger this event, you will have to call the \"set()\" function on the contract again. Once the update transaction is mined, the event will fire. This is what it looks like in the browser console. This should give you a good overview of how to connect to a contract and interact with it using web3.js","title":"Watch for events"},{"location":"S04-developer-tooling/M3-infura/L1/","text":"In our section on \"Development Workflow\" and \"Users in the Mental Model,\" we described our interactions with the Ethereum network going through a network gateway. In the \"Ethereum Basics\" of the course, we talked about Ethereum clients, nodes, and how to interact with the network you need to run a full node. However, for developers just starting on Ethereum or users who don't have easy access (or knowledge) of an Ethereum node, you can use an Ethereum gateway service called Infura. Infura provides a simple API access point for not only the Ethereum mainnet and all public testnets, but also for IPFS, the Ethereum 2.0 Beacon Chain, Filecoin, Optimism, Arbitrum and Polygon. Incorporating Infura into your workflow will make deploying much easier. As your project grows, you can absolutely consider other options, but it's a nice, easy onramp to development. Follow the steps below to sign up for Infura (there are also great step-by-step instructions on Infura's website here ): Register First thing, register for a free account on Infura. For smaller development projects (or even medium-sized ones), Infura's free tier is more than capable of handling your requests. Coogan is currently running an Eth2 validator client on Infura's free tier (you'll see it in the screenshots below!) Setting Up Your First Project Once you've registered, you'll click the Ethereum logo on the left-hand side. (see below) You can also see the other available network endpoints listed here, which will be more since we took the above screenshot! Next, click \u201cCreate New Project\u201d in upper right hand corner: Name your project and go to \u201cSettings.\u201d There, you'll be able to access the credentials you'll use in your local environment (either Truffle or some other framework) to help make deployment easy. Again, these are your personal, sensitive credentials so be sure to store them in a .env file that you add to your .gitignore doc! Read more about that here. A .env file for our Infura credentials will look something like: MNEMONIC=\"Your MNEMONICs\" // A wallet with enough ETH INFURA_URL=\"Your Infura URL with API key\" source Incorporating Infura Into Your Development Environment Now let's see how we take our Infura credentials and plug them into a development framework like Truffle. For this, we're going to dive deeper into our truffle-config.js file As you might have gathered by now, the Truffle configuration file ( truffle-config.js ) is the backbone of a Truffle-based project. Thus far we\u2019ve only seen it used to store details of the different networks we\u2019re targeting (e.g. local, testnet, mainet, etc), but it\u2019s actually used for a lot more, such as network configuration. To illustrate this, let's look at the networks section of our truffle-config.js from our SimpleStorage example we've been working on in previous lessons. Here's a sample truffle-config.js file that targets the Ganache endpoint we setup earlier: module . exports = { networks : { development : { host : \"127.0.0.1\" , port : 8545 , network_id : \"*\" // Match any network id } }, compilers : { solc : { version : \"^0.8.0\" } } }; When we run truffle init earlier, though, the truffle-config.js contains a ton of helpful material that's been commented out. For example, here's a section under networks : // Useful for deploying to a public network. // NB: It's important to wrap the provider as a function. // ropsten: { // provider: () => new HDWalletProvider(mnemonic, `https://ropsten.infura.io/v3/YOUR-PROJECT-ID`), // network_id: 3, // Ropsten's id // gas: 5500000, // Ropsten has a lower block limit than mainnet // confirmations: 2, // # of confs to wait between deployments. (default: 0) // timeoutBlocks: 200, // # of blocks before a deployment times out (minimum/default: 50) // skipDryRun: true // Skip dry run before migrations? (default: false for public nets ) // }, To activate this, all we have to do is comment the code back in ( \u2318 / in VSCode) and substitute in the credentials we got from Infura. Note that you need to change the YOUR-PROJECT-ID and well as whatever subdomain network you'd like to work from. Be sure as well to change the network_id to the appropriate one for your network. To grab our Infura credentials safely from our .env file, you'll include this at the top of truffle-config.js (HDWallet is provided, we just need to comment it out): const HDWallet = require ( '@truffle/hdwallet-provider' ); const dotenv = require ( 'dotenv' ); dotenv . config (); const mnemonic = process . env . MNEMONIC ; (For reference, in the above snippet we're also using Truffle\u2019s HDWalletProvider library enabling us to use a custom mnemonic as part of the deployment.) We can change the name of our testnet to any one we'd like. Here's what it would look like for Rinkeby: rinkeby : { provider : () => new HDWalletProvider ( mnemonic , process . env . INFURA_URL ), network_id : \"4\" , gas : 5500000 } To migrate SimpleStorage to Rinkeby, we run the following command: $ truffle migrate --network rinkeby That's it! If you have enough Rinkeby test Eth in the account associated with your mnemonic phrase, your contract is now deployed to a public testnet using Infura! Later in the course, we'll discuss how Truffle and Infura can be used in the truffle-config.js file to deploy to multiple networks, including non-Ethereum networks.","title":"Index"},{"location":"S04-developer-tooling/M3-infura/L1/#register","text":"First thing, register for a free account on Infura. For smaller development projects (or even medium-sized ones), Infura's free tier is more than capable of handling your requests. Coogan is currently running an Eth2 validator client on Infura's free tier (you'll see it in the screenshots below!)","title":"Register"},{"location":"S04-developer-tooling/M3-infura/L1/#setting-up-your-first-project","text":"Once you've registered, you'll click the Ethereum logo on the left-hand side. (see below) You can also see the other available network endpoints listed here, which will be more since we took the above screenshot! Next, click \u201cCreate New Project\u201d in upper right hand corner: Name your project and go to \u201cSettings.\u201d There, you'll be able to access the credentials you'll use in your local environment (either Truffle or some other framework) to help make deployment easy. Again, these are your personal, sensitive credentials so be sure to store them in a .env file that you add to your .gitignore doc! Read more about that here. A .env file for our Infura credentials will look something like: MNEMONIC=\"Your MNEMONICs\" // A wallet with enough ETH INFURA_URL=\"Your Infura URL with API key\" source","title":"Setting Up Your First Project"},{"location":"S04-developer-tooling/M3-infura/L1/#incorporating-infura-into-your-development-environment","text":"Now let's see how we take our Infura credentials and plug them into a development framework like Truffle. For this, we're going to dive deeper into our truffle-config.js file As you might have gathered by now, the Truffle configuration file ( truffle-config.js ) is the backbone of a Truffle-based project. Thus far we\u2019ve only seen it used to store details of the different networks we\u2019re targeting (e.g. local, testnet, mainet, etc), but it\u2019s actually used for a lot more, such as network configuration. To illustrate this, let's look at the networks section of our truffle-config.js from our SimpleStorage example we've been working on in previous lessons. Here's a sample truffle-config.js file that targets the Ganache endpoint we setup earlier: module . exports = { networks : { development : { host : \"127.0.0.1\" , port : 8545 , network_id : \"*\" // Match any network id } }, compilers : { solc : { version : \"^0.8.0\" } } }; When we run truffle init earlier, though, the truffle-config.js contains a ton of helpful material that's been commented out. For example, here's a section under networks : // Useful for deploying to a public network. // NB: It's important to wrap the provider as a function. // ropsten: { // provider: () => new HDWalletProvider(mnemonic, `https://ropsten.infura.io/v3/YOUR-PROJECT-ID`), // network_id: 3, // Ropsten's id // gas: 5500000, // Ropsten has a lower block limit than mainnet // confirmations: 2, // # of confs to wait between deployments. (default: 0) // timeoutBlocks: 200, // # of blocks before a deployment times out (minimum/default: 50) // skipDryRun: true // Skip dry run before migrations? (default: false for public nets ) // }, To activate this, all we have to do is comment the code back in ( \u2318 / in VSCode) and substitute in the credentials we got from Infura. Note that you need to change the YOUR-PROJECT-ID and well as whatever subdomain network you'd like to work from. Be sure as well to change the network_id to the appropriate one for your network. To grab our Infura credentials safely from our .env file, you'll include this at the top of truffle-config.js (HDWallet is provided, we just need to comment it out): const HDWallet = require ( '@truffle/hdwallet-provider' ); const dotenv = require ( 'dotenv' ); dotenv . config (); const mnemonic = process . env . MNEMONIC ; (For reference, in the above snippet we're also using Truffle\u2019s HDWalletProvider library enabling us to use a custom mnemonic as part of the deployment.) We can change the name of our testnet to any one we'd like. Here's what it would look like for Rinkeby: rinkeby : { provider : () => new HDWalletProvider ( mnemonic , process . env . INFURA_URL ), network_id : \"4\" , gas : 5500000 } To migrate SimpleStorage to Rinkeby, we run the following command: $ truffle migrate --network rinkeby That's it! If you have enough Rinkeby test Eth in the account associated with your mnemonic phrase, your contract is now deployed to a public testnet using Infura! Later in the course, we'll discuss how Truffle and Infura can be used in the truffle-config.js file to deploy to multiple networks, including non-Ethereum networks.","title":"Incorporating Infura Into Your Development Environment"},{"location":"S04-developer-tooling/M4-truffle-deep-dive/L1-truffle-tests/","text":"","title":"Index"},{"location":"S04-developer-tooling/M4-truffle-deep-dive/L2-debug-config-forking/","text":"","title":"Index"},{"location":"S05a-defi/M1-intro/L1-what-is-defi/","text":"What is DeFi? Finance is defined as the management of money and includes activities like saving, borrowing, lending, investing, budgeting, and forecasting. Finance can be seen as a societal tool to manage resources, risk, and rewards across space and time between entities. Decentralized Finance (DeFi) is a term used for software built on programmable open-source blockchains using smart contracts. The aim is to transform traditional financial products into reliable, permissionless, transparent, and censorship-resistant protocols without centralized intermediaries. In some ways, DeFi protocol devs are writing firmware for scalable social collaboration and resource allocation. They extend the internet of value to more complex activities. DeFi protocols share three interesting characteristics among many: Interoperability: The ability to share data and work with each other Composability: money legos, aka they be used in different ways to create new things Immutability: the inability for the core logic to be changed, allowing for more trust. Permissionless: the ability to interact with a protocol without third party permission Auditable: the history of its activities can be investigated by anyone These properties give developers the ability to string together a series of protocols to create new and exciting applications. DeFi also addresses issues in centralized finance related to: Centralized control Limited access and options Lack of interoperability and portability Lack of Transparency High cost Misaligned incentives DeFi apps aim to increase choice, innovation, access, efficiency, speed, transparency, auditability and autonomy while lowering the costs of doing business and reducing systemic risk from too big to fail entities. Anyone with an internet connection can access DeFi Apps and protocols, extending the internet of information to the \u201cinternet of value\u201d.","title":"What is DeFi?"},{"location":"S05a-defi/M1-intro/L1-what-is-defi/#what-is-defi","text":"Finance is defined as the management of money and includes activities like saving, borrowing, lending, investing, budgeting, and forecasting. Finance can be seen as a societal tool to manage resources, risk, and rewards across space and time between entities. Decentralized Finance (DeFi) is a term used for software built on programmable open-source blockchains using smart contracts. The aim is to transform traditional financial products into reliable, permissionless, transparent, and censorship-resistant protocols without centralized intermediaries. In some ways, DeFi protocol devs are writing firmware for scalable social collaboration and resource allocation. They extend the internet of value to more complex activities. DeFi protocols share three interesting characteristics among many: Interoperability: The ability to share data and work with each other Composability: money legos, aka they be used in different ways to create new things Immutability: the inability for the core logic to be changed, allowing for more trust. Permissionless: the ability to interact with a protocol without third party permission Auditable: the history of its activities can be investigated by anyone These properties give developers the ability to string together a series of protocols to create new and exciting applications. DeFi also addresses issues in centralized finance related to: Centralized control Limited access and options Lack of interoperability and portability Lack of Transparency High cost Misaligned incentives DeFi apps aim to increase choice, innovation, access, efficiency, speed, transparency, auditability and autonomy while lowering the costs of doing business and reducing systemic risk from too big to fail entities. Anyone with an internet connection can access DeFi Apps and protocols, extending the internet of information to the \u201cinternet of value\u201d.","title":"What is DeFi?"},{"location":"S05a-defi/M1-intro/L2-key-terms/","text":"Key Terms To understand decentralized finance, we must first understand some key terms in finance. Then we can look into the important key terms that are unique to DeFi. As mentioned, finance can be defined as the \u201cstudy of systems of money, investments, and other financial instruments\u201d. It can be seen as a societal tool to manage resources nominated in money, risk, and rewards across space and time between entities. DeFi upgrades this to occur on the \u201cinternet of value\u201d via programmable blockchains like Ethereum with protocols written in smart contracts. Economics in 30 seconds A key foundation of finance is economics which deals with how people interact with value , specifically the production, distribution, and consumption of goods and services. Core to this idea is the concept of scarcity , or simply the gap between limited resources and unlimited wants. To solve this problem we look towards allocating resources to the most productive uses. We use market based systems based on property rights to allow individual entities to own and allocate resources to where they best see fit. From this arises supply and demand another central idea in economics. In finance, scarcity, allocation and supply and demand translate into deploying limited amounts of capital across a range of possible investments. As we will see later, smart contract based systems make it easy to enforce and audit ownership, and what owners can do with their digital assets. Key Financial Terms That Appear in DeFi Finance extends economics to the management of money and investments. Money has certain properties , some of which are the ability to quantify and transfer value. The most common example of money is fiat currency , a type of money a government has declared legal tender that allows for the settlement of private or public debts within a political jurisdiction. Examples of fiat currencies are the United States Dollar $, European Union\u2019s Euro \u20ac, The People\u2019s Republic of China\u2019s Renminbi RMB, Japanese Yen \u00a5, South African Rand R. Once we have money, we want to grow it. This is because inflation slowly eats away at the value of money. A dollar today is worth less than a dollar 20 years ago. So we must invest our money to keep up. In finance that means investing in financial instruments defined as assets or bundles of capital represented by real or virtual documents. Not all opportunities or financial assets are equal. Out of this emerges a central idea in finance: risk , which is the probability of losing money. Risk for a financial product can be affected by the type of asset, time an asset is held, liquidity for the asset, depreciation, volatility and more. From risk emerges the risk-return trade off that states the potential return rises with an increase in risk. Individuals use this to assess an investment and consider many factors, like their overall risk tolerance, the potential to replace lost funds, the investment\u2019s return in relation to other assets and more. In simple terms, the riskier the project, the greater the expected. A little more context can be found here . \ud83d\uddbc Add Risk Reward Line here. In the crypto industry and DeFi one of the main sources of risk is due to volatility . Volatility is the unsteady spread of an asset's price movements around its average price. The greater the swings, the more volatile, the riskier the asset is perceived. Volatility can be measured in different ways. You can see volatility in action here . \ud83d\uddbc Add Volatility graph. This volatility contributes to exchange rate risk , or the risk of devaluation of one currency compared to another. An example can be holding ETH compared to the US dollar, then ETH\u2019s price drops 15% in relation to the dollar. This problem is further compounded by holding two volatile currencies in relation to each other. Volatility emerges from various sources including market liquidity risk , or the lack of buyers and sellers. Liquidity is the ease in which you can buy or sell an asset. The less liquidity an asset has, the greater the volatility of an asset\u2019s price when buying or selling. Liquidity is the lifeblood of DeFi , since large amounts of liquidity also helps to create price stability. Illiquid assets have wilder price swings, making them less predictable, risker for network participants, and contributes to higher slippage . Slippage occurs when a trade settles for an average price that is different from what was requested. \ud83d\uddbc Add Liquidity Think about a market of lots of buyers and sellers for an asset. A deep pool of buyers and sellers results in a narrow bid-ask spread , since you can find alternative takers if someone quotes a price that deviates from the crowd. In DeFi, slippage is most often seen when trading niche tokens with small networks or limited liquidity on decentralized exchanges, which are covered in a later section. \ud83d\uddbc Add Bid-Ask Spread picture To help reduce volatility and risk in DeFi, stablecoins were created. Stablecoins are fungible tokens that mimic a fiat currency\u2019s performance through a peg . Fungibility is the ability of a good or asset to be exchanged for another of the same kind, like exchanging two different dollars. A peg is a system by which one currency latches on to another to form a tight correlation. Stablecoins can maintain this peg in a variety of ways discussed in a later section. One method is through the use of collateralization and liquidation. DeFi protocols rely on collateral to allow for permissionless participation. Collateral is an asset a borrower pledges to a lender in case they cannot pay back a loan. In DeFi, collateral is in the form of crypto assets like ETH, other tokens with deep levels of liquidity. Even NFTs which are non-fungible tokens issued to prove ownership of a unique digital asset, can be staked as collateral. Staking refers to depositing assets into an escrow contract thereby passing custody of the collateral to the protocol. \ud83d\uddbc Add Staking Collateral Visualization Due to the volatility of crypto assets and the lack of decentralized credit systems, most DeFi protocols rely on the overcollateralization pattern to issue assets. This means requiring to cover over 100% of the loan. Say you wish to get $100 in one crypto asset, you will require collateral of $100 in value in another. These assets are in sense collateralized loans and are the backbone of DeFi because they allow open, pseudo-anonymous finance , without credit scores or any sort of formal identity tied to a loan. Through overcollateralization, protocols can mitigate their risk, while providing access and possibilities for returns. This functioning is common in DeFi protocols and is explained here . The loan to collateral ratio expresses the degree to which a protocol is overcollateralized. The total value locked represents the amount of funds in a contract and is a proxy for contract's popularity. Due to volatility, it is possible for the value of the collateral to drop below the value of the borrowed asset. When this occurs DeFi protocols typically begin to liquidate the users assets to maintain stability. Liquidation is the process of selling/distributing assets to settle debts. This is one of the ways a user can get rekt . Another is via rug pulls , where protocol developers run off with the assets, or DeFi hacks , where malicious actors exploit a bug in the contract code . The aim of many protocol developers is to achieve deep liquidity, broad usage and network effects . The ideal point culminates in a Schelling Point or a natural place of collaboration, brand awareness, and user evangelism. To achieve this protocol developers rely on incentives to encourage and discourage certain types of behavior. One method to bootstrap the network is via liquidity mining programs. These programs can be seen as part of a marketing program to onboard users to engage with protocol. Users engage in yield farming to find the best APY by shifting capital across various places. \ud83d\uddbc Add Liquidity Mining Picture There are various protocols like Yearn.Finance which help users automate strategies to maximize APY and the lowest cost through the use of vaults {target=_blank}. There are some indicators that DeFi protocol Devs should know {target=_blank}. Additional Resources DeFi and the Future of Finance by Campbell R. Harvey (Duke University){target=_blank}, Ashwin Ramachandran (Dragonfly Capital){target=_blank} and Joey Santoro (Fei Protocol){target=_blank} page 1 - 12 DeFi Primitives Via Campbell Harvey - Duke University The Future of DeFi by Linda Xie The Network Effects Manual by nfx","title":"Key Terms"},{"location":"S05a-defi/M1-intro/L2-key-terms/#key-terms","text":"To understand decentralized finance, we must first understand some key terms in finance. Then we can look into the important key terms that are unique to DeFi. As mentioned, finance can be defined as the \u201cstudy of systems of money, investments, and other financial instruments\u201d. It can be seen as a societal tool to manage resources nominated in money, risk, and rewards across space and time between entities. DeFi upgrades this to occur on the \u201cinternet of value\u201d via programmable blockchains like Ethereum with protocols written in smart contracts.","title":"Key Terms"},{"location":"S05a-defi/M1-intro/L2-key-terms/#economics-in-30-seconds","text":"A key foundation of finance is economics which deals with how people interact with value , specifically the production, distribution, and consumption of goods and services. Core to this idea is the concept of scarcity , or simply the gap between limited resources and unlimited wants. To solve this problem we look towards allocating resources to the most productive uses. We use market based systems based on property rights to allow individual entities to own and allocate resources to where they best see fit. From this arises supply and demand another central idea in economics. In finance, scarcity, allocation and supply and demand translate into deploying limited amounts of capital across a range of possible investments. As we will see later, smart contract based systems make it easy to enforce and audit ownership, and what owners can do with their digital assets.","title":"Economics in 30 seconds"},{"location":"S05a-defi/M1-intro/L2-key-terms/#key-financial-terms-that-appear-in-defi","text":"Finance extends economics to the management of money and investments. Money has certain properties , some of which are the ability to quantify and transfer value. The most common example of money is fiat currency , a type of money a government has declared legal tender that allows for the settlement of private or public debts within a political jurisdiction. Examples of fiat currencies are the United States Dollar $, European Union\u2019s Euro \u20ac, The People\u2019s Republic of China\u2019s Renminbi RMB, Japanese Yen \u00a5, South African Rand R. Once we have money, we want to grow it. This is because inflation slowly eats away at the value of money. A dollar today is worth less than a dollar 20 years ago. So we must invest our money to keep up. In finance that means investing in financial instruments defined as assets or bundles of capital represented by real or virtual documents. Not all opportunities or financial assets are equal. Out of this emerges a central idea in finance: risk , which is the probability of losing money. Risk for a financial product can be affected by the type of asset, time an asset is held, liquidity for the asset, depreciation, volatility and more. From risk emerges the risk-return trade off that states the potential return rises with an increase in risk. Individuals use this to assess an investment and consider many factors, like their overall risk tolerance, the potential to replace lost funds, the investment\u2019s return in relation to other assets and more. In simple terms, the riskier the project, the greater the expected. A little more context can be found here . \ud83d\uddbc Add Risk Reward Line here. In the crypto industry and DeFi one of the main sources of risk is due to volatility . Volatility is the unsteady spread of an asset's price movements around its average price. The greater the swings, the more volatile, the riskier the asset is perceived. Volatility can be measured in different ways. You can see volatility in action here . \ud83d\uddbc Add Volatility graph. This volatility contributes to exchange rate risk , or the risk of devaluation of one currency compared to another. An example can be holding ETH compared to the US dollar, then ETH\u2019s price drops 15% in relation to the dollar. This problem is further compounded by holding two volatile currencies in relation to each other. Volatility emerges from various sources including market liquidity risk , or the lack of buyers and sellers. Liquidity is the ease in which you can buy or sell an asset. The less liquidity an asset has, the greater the volatility of an asset\u2019s price when buying or selling. Liquidity is the lifeblood of DeFi , since large amounts of liquidity also helps to create price stability. Illiquid assets have wilder price swings, making them less predictable, risker for network participants, and contributes to higher slippage . Slippage occurs when a trade settles for an average price that is different from what was requested. \ud83d\uddbc Add Liquidity Think about a market of lots of buyers and sellers for an asset. A deep pool of buyers and sellers results in a narrow bid-ask spread , since you can find alternative takers if someone quotes a price that deviates from the crowd. In DeFi, slippage is most often seen when trading niche tokens with small networks or limited liquidity on decentralized exchanges, which are covered in a later section. \ud83d\uddbc Add Bid-Ask Spread picture To help reduce volatility and risk in DeFi, stablecoins were created. Stablecoins are fungible tokens that mimic a fiat currency\u2019s performance through a peg . Fungibility is the ability of a good or asset to be exchanged for another of the same kind, like exchanging two different dollars. A peg is a system by which one currency latches on to another to form a tight correlation. Stablecoins can maintain this peg in a variety of ways discussed in a later section. One method is through the use of collateralization and liquidation. DeFi protocols rely on collateral to allow for permissionless participation. Collateral is an asset a borrower pledges to a lender in case they cannot pay back a loan. In DeFi, collateral is in the form of crypto assets like ETH, other tokens with deep levels of liquidity. Even NFTs which are non-fungible tokens issued to prove ownership of a unique digital asset, can be staked as collateral. Staking refers to depositing assets into an escrow contract thereby passing custody of the collateral to the protocol. \ud83d\uddbc Add Staking Collateral Visualization Due to the volatility of crypto assets and the lack of decentralized credit systems, most DeFi protocols rely on the overcollateralization pattern to issue assets. This means requiring to cover over 100% of the loan. Say you wish to get $100 in one crypto asset, you will require collateral of $100 in value in another. These assets are in sense collateralized loans and are the backbone of DeFi because they allow open, pseudo-anonymous finance , without credit scores or any sort of formal identity tied to a loan. Through overcollateralization, protocols can mitigate their risk, while providing access and possibilities for returns. This functioning is common in DeFi protocols and is explained here . The loan to collateral ratio expresses the degree to which a protocol is overcollateralized. The total value locked represents the amount of funds in a contract and is a proxy for contract's popularity. Due to volatility, it is possible for the value of the collateral to drop below the value of the borrowed asset. When this occurs DeFi protocols typically begin to liquidate the users assets to maintain stability. Liquidation is the process of selling/distributing assets to settle debts. This is one of the ways a user can get rekt . Another is via rug pulls , where protocol developers run off with the assets, or DeFi hacks , where malicious actors exploit a bug in the contract code . The aim of many protocol developers is to achieve deep liquidity, broad usage and network effects . The ideal point culminates in a Schelling Point or a natural place of collaboration, brand awareness, and user evangelism. To achieve this protocol developers rely on incentives to encourage and discourage certain types of behavior. One method to bootstrap the network is via liquidity mining programs. These programs can be seen as part of a marketing program to onboard users to engage with protocol. Users engage in yield farming to find the best APY by shifting capital across various places. \ud83d\uddbc Add Liquidity Mining Picture There are various protocols like Yearn.Finance which help users automate strategies to maximize APY and the lowest cost through the use of vaults {target=_blank}. There are some indicators that DeFi protocol Devs should know {target=_blank}.","title":"Key Financial Terms That Appear in DeFi"},{"location":"S05a-defi/M1-intro/L2-key-terms/#additional-resources","text":"DeFi and the Future of Finance by Campbell R. Harvey (Duke University){target=_blank}, Ashwin Ramachandran (Dragonfly Capital){target=_blank} and Joey Santoro (Fei Protocol){target=_blank} page 1 - 12 DeFi Primitives Via Campbell Harvey - Duke University The Future of DeFi by Linda Xie The Network Effects Manual by nfx","title":"Additional Resources"},{"location":"S05a-defi/M2-stablecoins/L1/","text":"What are Stablecoins A critical issue in cryptocurrencies is extreme volatility, especially when compared to fiat currencies. It\u2019s hard to enter into any profitable financial agreement when prices can fluctuate wildly. Stablecoins were created to fix this issue. Stablecoins are cryptocurrencies built using smart contracts on programmatic blockchains which significantly reduces or eliminates price volatility by aiming to peg to a fiat currency like the US dollar. This gives users a tool for managing risk and allowing them to engage with DeFi protocols reliably. Stablecoins are one of the cornerstones of the DeFi industry, as a user cannot reliably enter or exit a protocol without a stable currency. They also provide access to stable currencies to unbanked and underbanked people around the world , helping people to save, pay, invest and spend in more reliable ways. Stablecoins allows people to choose their economic policy based on their interest and objectives. There are four types of stablecoins, each collateralized by different assets and its own complexity/centralization profile. The types are ranked from most centralized/less complex to less centralized/more complex. Fiat backed Commodity backed Crypto backed Algorithmic Fractional Central Bank Digital Currencies* A good mental model for a Stablecoin is the paper money you have in your pocket. Think of it as a programmable IOU that everyone in your community would accept as payment. There are three things to consider when looking at stablecoins: Type of collateral Collateralization ratio Degree of centralization A general mental model could be that the simpler the stablecoin it is to understand the more centralized it is. The exception would be Central Bank Digital Currencies which could be complex, opaque, and highly centralized due to political issues. Fiat Backed Stablecoins These are backed by US dollars or a government currency in a bank account. These stablecoins are collateralized by US Dollars in bank accounts and are audited periodically to maintain their assurances. Examples include Tether\u2019s USDT and Circle\u2019s USDC . Fiat backed stablecoins are collateralized at 100% with dollars. In the case of Tether, it is collateralized with dollar and dollar equivalents (financial instruments that can be quickly turned to cash without losing much value){target=_blank}. These are the simplest to understand, since from a technical perspective the issuance is very simple. There is one dollar in a bank account for every token on the network. USDT and USDC are by far the most popular stablecoins for their ease of use. However, with this simplicity comes the centralization and the possibility of censorship. Both USDT and USDC are able to add users to blocklists and freeze their assets. Commodity backed Stablecoins Backed by gold or another asset. An example includes Paxos Gold . Every PAX Gold token is backed by an ounce of allocated gold. Again this is easy to understand, however the issuer had the power to place users on a blocklist. Furthermore, there is the additional complexity of the volatility of the price of gold which is higher than the fiat currencies. Crypto Collateralized Backed by crypto assets like ETH or other tokens as collateral. Due to the cryptocurrency\u2019s volatility, these assets need over 150% collateral (250% recommended){target=_blank} to deal with volatility. The prominent example is MakerDAO\u2019s DAI . Best known for introducing the Collateralized Debt Position (CDP){target=_blank} . There are many advantages to crypto collateralized stablecoins. Because the asset lives on-chain, the stablecoin can be audited by anyone at any time without permission . Furthermore DAI is an essential money lego and can be built upon and easily integrated into any project. It can also generate interest. Along with transparency into its financial status, MakerDAO, the entity behind DAI, has a transparent governance system which allows the community members who hold MAKER tokens to vote on the management of the stablecoin. It\u2019s also a fully decentralized DAO , short for decentralized autonomous organization . Algorithmic Rebase Tokens Self-balancing through incentives and algorithms and non-collateralized. These use smart contract logic to expand and contract the supply of tokens to maintain their peg. Examples include AmpleForth\u2019s AMPL & Base Protocol's BASE . One can get a A Visual Explanation of Algorithmic Stablecoins by Haseeb Qureshi . Fractional Stablecoins Partially backed by collateral at 100% or less and partially stabilized algorithmically. The purpose is to improve capital efficiency. Examples include FRAX and Iron Finance\u2019s IRON . You can get a feeling for these via A Visual Explanation of FRAX by Haseeb Qureshi . Fractional stablecoins are a work in progress and have suffered from \u201crun on the bank\u201d , shakes the market\u2019s confidence. This causes a self fulfilling prophecy of capital withdrawals at the same time. Like a game of musical chairs, someone will be left standing. Seigniorage Seigniorage typically involves at least two tokens. One representing the stable token. While the other attempts to stabilize the token through actively adjusting the stables supply. The volatility, either through profit or loss, is passed on to the other token(s){target=_blank}. A few examples of Seigniorage Stablecoins are Empty Set Dollar, Basis, and Terra. Terra being the only one mentioned to have maintained it\u2019s peg. A typical, and often short lived, mechanism employed is in the use of Seigniorage Shares . Often recognisable by the Stable Token, Shares Token, and Bond Token. Central Bank Digital Currencies - CBDCs These are government issued fiat currencies which utilize distributed ledger technology like Ethereum. As of 2021, China has begun to pilots for its Digital Yuan and five countries in the Caribbean have already launched them . There are also currently CBDC pilots in 14 countries including Sweden, South Korea and China. You can see up to date information on CBDC\u2019s via the Atlantic Council\u2019s CBDC tracker. There are some interesting DeFi primitives that make this technology possible. The first is the ERC-20 standard , which standardizes fungible tokens. Next, the possibility of escrow contracts allows for collateral to be deposited into a protocol, giving the protocol custody over those funds. Next the ability to alter the supply is necessary. To expand the supply the protocol needs to mint tokens. To contract the supply, it needs to burn tokens. An interesting DeFi primitive that has evolved from algorithmic stablecoins is the concept of rebasing . The peg adjusts by expanding or contracting the supply of tokens depending on the price. If the price goes up or down 10%, the supply will expand or contract 10%. Rebasing makes possible an elastic supply of tokens that change based on any condition, in this case it being the market price.","title":"What are Stablecoins"},{"location":"S05a-defi/M2-stablecoins/L1/#what-are-stablecoins","text":"A critical issue in cryptocurrencies is extreme volatility, especially when compared to fiat currencies. It\u2019s hard to enter into any profitable financial agreement when prices can fluctuate wildly. Stablecoins were created to fix this issue. Stablecoins are cryptocurrencies built using smart contracts on programmatic blockchains which significantly reduces or eliminates price volatility by aiming to peg to a fiat currency like the US dollar. This gives users a tool for managing risk and allowing them to engage with DeFi protocols reliably. Stablecoins are one of the cornerstones of the DeFi industry, as a user cannot reliably enter or exit a protocol without a stable currency. They also provide access to stable currencies to unbanked and underbanked people around the world , helping people to save, pay, invest and spend in more reliable ways. Stablecoins allows people to choose their economic policy based on their interest and objectives. There are four types of stablecoins, each collateralized by different assets and its own complexity/centralization profile. The types are ranked from most centralized/less complex to less centralized/more complex. Fiat backed Commodity backed Crypto backed Algorithmic Fractional Central Bank Digital Currencies* A good mental model for a Stablecoin is the paper money you have in your pocket. Think of it as a programmable IOU that everyone in your community would accept as payment. There are three things to consider when looking at stablecoins: Type of collateral Collateralization ratio Degree of centralization A general mental model could be that the simpler the stablecoin it is to understand the more centralized it is. The exception would be Central Bank Digital Currencies which could be complex, opaque, and highly centralized due to political issues.","title":"What are Stablecoins"},{"location":"S05a-defi/M2-stablecoins/L1/#fiat-backed-stablecoins","text":"These are backed by US dollars or a government currency in a bank account. These stablecoins are collateralized by US Dollars in bank accounts and are audited periodically to maintain their assurances. Examples include Tether\u2019s USDT and Circle\u2019s USDC . Fiat backed stablecoins are collateralized at 100% with dollars. In the case of Tether, it is collateralized with dollar and dollar equivalents (financial instruments that can be quickly turned to cash without losing much value){target=_blank}. These are the simplest to understand, since from a technical perspective the issuance is very simple. There is one dollar in a bank account for every token on the network. USDT and USDC are by far the most popular stablecoins for their ease of use. However, with this simplicity comes the centralization and the possibility of censorship. Both USDT and USDC are able to add users to blocklists and freeze their assets.","title":"Fiat Backed Stablecoins"},{"location":"S05a-defi/M2-stablecoins/L1/#commodity-backed-stablecoins","text":"Backed by gold or another asset. An example includes Paxos Gold . Every PAX Gold token is backed by an ounce of allocated gold. Again this is easy to understand, however the issuer had the power to place users on a blocklist. Furthermore, there is the additional complexity of the volatility of the price of gold which is higher than the fiat currencies.","title":"Commodity backed Stablecoins"},{"location":"S05a-defi/M2-stablecoins/L1/#crypto-collateralized","text":"Backed by crypto assets like ETH or other tokens as collateral. Due to the cryptocurrency\u2019s volatility, these assets need over 150% collateral (250% recommended){target=_blank} to deal with volatility. The prominent example is MakerDAO\u2019s DAI . Best known for introducing the Collateralized Debt Position (CDP){target=_blank} . There are many advantages to crypto collateralized stablecoins. Because the asset lives on-chain, the stablecoin can be audited by anyone at any time without permission . Furthermore DAI is an essential money lego and can be built upon and easily integrated into any project. It can also generate interest. Along with transparency into its financial status, MakerDAO, the entity behind DAI, has a transparent governance system which allows the community members who hold MAKER tokens to vote on the management of the stablecoin. It\u2019s also a fully decentralized DAO , short for decentralized autonomous organization .","title":"Crypto Collateralized"},{"location":"S05a-defi/M2-stablecoins/L1/#algorithmic","text":"","title":"Algorithmic"},{"location":"S05a-defi/M2-stablecoins/L1/#rebase-tokens","text":"Self-balancing through incentives and algorithms and non-collateralized. These use smart contract logic to expand and contract the supply of tokens to maintain their peg. Examples include AmpleForth\u2019s AMPL & Base Protocol's BASE . One can get a A Visual Explanation of Algorithmic Stablecoins by Haseeb Qureshi .","title":"Rebase Tokens"},{"location":"S05a-defi/M2-stablecoins/L1/#fractional-stablecoins","text":"Partially backed by collateral at 100% or less and partially stabilized algorithmically. The purpose is to improve capital efficiency. Examples include FRAX and Iron Finance\u2019s IRON . You can get a feeling for these via A Visual Explanation of FRAX by Haseeb Qureshi . Fractional stablecoins are a work in progress and have suffered from \u201crun on the bank\u201d , shakes the market\u2019s confidence. This causes a self fulfilling prophecy of capital withdrawals at the same time. Like a game of musical chairs, someone will be left standing.","title":"Fractional Stablecoins"},{"location":"S05a-defi/M2-stablecoins/L1/#seigniorage","text":"Seigniorage typically involves at least two tokens. One representing the stable token. While the other attempts to stabilize the token through actively adjusting the stables supply. The volatility, either through profit or loss, is passed on to the other token(s){target=_blank}. A few examples of Seigniorage Stablecoins are Empty Set Dollar, Basis, and Terra. Terra being the only one mentioned to have maintained it\u2019s peg. A typical, and often short lived, mechanism employed is in the use of Seigniorage Shares . Often recognisable by the Stable Token, Shares Token, and Bond Token.","title":"Seigniorage"},{"location":"S05a-defi/M2-stablecoins/L1/#central-bank-digital-currencies-cbdcs","text":"These are government issued fiat currencies which utilize distributed ledger technology like Ethereum. As of 2021, China has begun to pilots for its Digital Yuan and five countries in the Caribbean have already launched them . There are also currently CBDC pilots in 14 countries including Sweden, South Korea and China. You can see up to date information on CBDC\u2019s via the Atlantic Council\u2019s CBDC tracker. There are some interesting DeFi primitives that make this technology possible. The first is the ERC-20 standard , which standardizes fungible tokens. Next, the possibility of escrow contracts allows for collateral to be deposited into a protocol, giving the protocol custody over those funds. Next the ability to alter the supply is necessary. To expand the supply the protocol needs to mint tokens. To contract the supply, it needs to burn tokens. An interesting DeFi primitive that has evolved from algorithmic stablecoins is the concept of rebasing . The peg adjusts by expanding or contracting the supply of tokens depending on the price. If the price goes up or down 10%, the supply will expand or contract 10%. Rebasing makes possible an elastic supply of tokens that change based on any condition, in this case it being the market price.","title":"Central Bank Digital Currencies - CBDCs"},{"location":"S05a-defi/M3-nfts/L1/","text":"","title":"Index"},{"location":"S05a-defi/M4-wrapped/L1/","text":"What are Wrapped Tokens? Wrapped tokens are a way to bridge cryptocurrencies between blockchains. They are used to represent tokens that are not native to a blockchain network. An example is using Bitcoin or Dogecoin on Ethereum. Wrapped tokens exist because different blockchain networks may offer different features and can\u2019t talk directly to each other. These help increase interoperability and liquidity between networks. Wrapped tokens by work by having a token deposited into an account and is digitally represented on a smart contract platform like Ethereum. The tokens are collateralized with the asset, typically at 1:1. The deposit and issuance happen through a custodian, an entity that holds the assets. The custodian can be a company like Circle/Coinbase (via USDC), a merchant, a multi-signature wallet, a DAO or a smart contract. To mint wrapped tokens, the custodian receives the asset and then issues it on the chain. Tokens are burned when the custodian receives a notice to release assets from the reserves. Users would want to have wrapped tokens on Ethereum because the assets could work to earn a yield within DeFi Apps. Instead of your Bitcoin or Dogecoin only gaining value through price appreciation, you can earn a yield by lending it on DeFi platforms. By putting your idle assets to work, you could earn a stream of funds. Also, by using Wrapped Bitcoin on Ethereum, you can settle transactions faster and access markets with deeper liquidity. Since DeFi platforms rely on over-collateralization to assure stability and what is being lent out is not the asset itself, there is less worry about losing your assets. Popular examples of wrapped tokens include WBTC , RenBTC, RenDoge, RenFIL, WETH. Ren Protocol specializes in wrapped tokens between chains. You can also check out BadgerDAO , which is dedicated to creating tools to onboard Bitcoin liquidity onto Ethereum to earn yield. WETH (wrapped ETH) is a special case of a wrapped token since it takes native ETH and wraps it in the ERC-20 standard. This allows ETH to be used in DeFi applications via a common set of rules , since ETH was created before the ERC-20 standard emerged. With this, ETH can be used as collateral in the network. Prior to WETH, to use ETH in a DeFi app would require swapping ETH into a token. As multiple chains emerge for different use cases, inter-blockchain liquidity will be emphasized across networks. Say moving between Polygon and Ethereum. Wrapped Tokens require some level of trust with the custodian. At some point, trustless or trust minimized solutions with no custodians will appear, allowing anyone to move assets between any chain. Additional Resources Article: What are Wrapped Tokens? Article: Understanding Wrapped Bitcoin and the Wrapped Tokens Framework Article: Wrapped Crypto Tokens, Explained Analysis: Poly Network via Rekt.news","title":"What are Wrapped Tokens?"},{"location":"S05a-defi/M4-wrapped/L1/#what-are-wrapped-tokens","text":"Wrapped tokens are a way to bridge cryptocurrencies between blockchains. They are used to represent tokens that are not native to a blockchain network. An example is using Bitcoin or Dogecoin on Ethereum. Wrapped tokens exist because different blockchain networks may offer different features and can\u2019t talk directly to each other. These help increase interoperability and liquidity between networks. Wrapped tokens by work by having a token deposited into an account and is digitally represented on a smart contract platform like Ethereum. The tokens are collateralized with the asset, typically at 1:1. The deposit and issuance happen through a custodian, an entity that holds the assets. The custodian can be a company like Circle/Coinbase (via USDC), a merchant, a multi-signature wallet, a DAO or a smart contract. To mint wrapped tokens, the custodian receives the asset and then issues it on the chain. Tokens are burned when the custodian receives a notice to release assets from the reserves. Users would want to have wrapped tokens on Ethereum because the assets could work to earn a yield within DeFi Apps. Instead of your Bitcoin or Dogecoin only gaining value through price appreciation, you can earn a yield by lending it on DeFi platforms. By putting your idle assets to work, you could earn a stream of funds. Also, by using Wrapped Bitcoin on Ethereum, you can settle transactions faster and access markets with deeper liquidity. Since DeFi platforms rely on over-collateralization to assure stability and what is being lent out is not the asset itself, there is less worry about losing your assets. Popular examples of wrapped tokens include WBTC , RenBTC, RenDoge, RenFIL, WETH. Ren Protocol specializes in wrapped tokens between chains. You can also check out BadgerDAO , which is dedicated to creating tools to onboard Bitcoin liquidity onto Ethereum to earn yield. WETH (wrapped ETH) is a special case of a wrapped token since it takes native ETH and wraps it in the ERC-20 standard. This allows ETH to be used in DeFi applications via a common set of rules , since ETH was created before the ERC-20 standard emerged. With this, ETH can be used as collateral in the network. Prior to WETH, to use ETH in a DeFi app would require swapping ETH into a token. As multiple chains emerge for different use cases, inter-blockchain liquidity will be emphasized across networks. Say moving between Polygon and Ethereum. Wrapped Tokens require some level of trust with the custodian. At some point, trustless or trust minimized solutions with no custodians will appear, allowing anyone to move assets between any chain.","title":"What are Wrapped Tokens?"},{"location":"S05a-defi/M4-wrapped/L1/#additional-resources","text":"Article: What are Wrapped Tokens? Article: Understanding Wrapped Bitcoin and the Wrapped Tokens Framework Article: Wrapped Crypto Tokens, Explained Analysis: Poly Network via Rekt.news","title":"Additional Resources"},{"location":"S05a-defi/M5a-dexes/L1/","text":"What are DEXes Decentralized Exchanges (DEX) are DeFi applications that allow users to trade cryptocurrencies peer-to-peer without an intermediary using Ethereum smart contracts. DEXs are non-custodial, provide greater access to tokens, are secure, require no signups and eliminate counterparty risk. However, scalability, gas fees and on/off ramps for assets remain a problem. There are three main types of DEXs: order books, automatic market makers and request for quote. This section will cover the most popular type of DEX called an Automated Market Maker and the Request For Quote Model, which has its distinct advantages. In addition, each has its distinct advantages and disadvantages.","title":"What are DEXes"},{"location":"S05a-defi/M5a-dexes/L1/#what-are-dexes","text":"Decentralized Exchanges (DEX) are DeFi applications that allow users to trade cryptocurrencies peer-to-peer without an intermediary using Ethereum smart contracts. DEXs are non-custodial, provide greater access to tokens, are secure, require no signups and eliminate counterparty risk. However, scalability, gas fees and on/off ramps for assets remain a problem. There are three main types of DEXs: order books, automatic market makers and request for quote. This section will cover the most popular type of DEX called an Automated Market Maker and the Request For Quote Model, which has its distinct advantages. In addition, each has its distinct advantages and disadvantages.","title":"What are DEXes"},{"location":"S05a-defi/M5b-amms/L1/","text":"Automated Market Makers - AMM An automated market maker (AMM){target=_blank} is a smart contract that holds assets and is always willing to quote you a price between two assets. You can trade against the AMM\u2019s capital in the smart contract instead of between peers. It uses the trades to update the size of the assets, and update their price accordingly. By raising the price for an asset based demand, the AMM can always guarantee liquidity albeit at higher and higher prices. There are various ones , however we will focus on the most important features popularized by UniSwap. Haseeb Qureshi explains UniSwap well here. We will cover another type of DEX protocol in a later section. This section will give an overview of two key concepts that make AMMs possible. Liquidity Pools Automated Market Makers rely on liquidity pools to source capital. Liquidity pools are collections of tokens locked into a smart contract. This allows for decentralized capital formation. They are used to facilitate trading by providing liquidity, defined as the ability to convert an asset into cash or its equivalents without greatly affecting its market price. This is important because an asset's value is determined by what others are willing to pay for it and the ease to which it can be bought or sold. The main ideas behind liquidity pools are: They are used to source capital which is used to provide liquidity. Liquidity is the ability to convert an asset into cash without affecting its price. They are useful because order book models are not feasible on-chain completely since market makers cannot update prices all the time due to gas fees and Ethereum\u2019s throughput being too slow. Liquidity pools source capital from anyone and are used to allow anyone to trade against the smart contract. Liquidity providers earn a fee for doing so in the proportion of capital they provide to the pool. To become a liquidity provider, users must deposit equal amounts of token based on their price into a pool. If they don\u2019t, they risk being arbitraged by traders who find a good deal. -AMMs like UniSwap hold liquidity pools in token pairs. An example can be the ETH - DAI or CRV - COMP (Curve to Compound Finance){target=_blank}. The downside : Because trades happen on-chain, bots can front-run transactions and attempt other sorts of attacks . This results in a user paying more than they intended. Front running occurs when bots read Ethereum's current set of unprocessed pending transactions called the mempool and find an opportunity to outbid a transaction to be processed by the network miner (or validator after ETH 2.0){target=_blank}. The bots cut in front of the line, resulting in a better price for them at the expense of the other trader. -This stems from the Miner Extractable Value , where a miner can dictate when, how and where a transaction will go into a block on Ethereum. When a transaction large enough to create slippage is sent to the network, bots will notice and set off a bidding war to capture the stop and front run. Bonding Curves The other key to Automated Market Makers is the bonding curve. A b onding curve is a mathematical formula used to describe the relationship between the price and the supply of an asset. This can be thought of as a deterministic pricing formula. This formula is called the Constant Product Formula in UniSwap. This curve can be represented in a smart contract with the ability to buy or sell the underlying token. Bonding Curves emerge out of the ability to escrow funds in a smart contract. The main ideas behind the Constant Product Formula are: -To always ensure liquidity for any asset by modeling the demand curve in the smart contract. Users trade against the smart contract, not between each other. k always has to stay the same number, no matter what x or y does. The price quoted is directly dependent on the size of the order. The trade-off for assured liquidity is slippage, also known as getting less for more. x * y = k x = supply of asset 1 y = supply of asset 2 k = Fixed Size of Pool The downside: Note that the further one moves along the curve, the less they get. In UniSwap, the slippage starts to seriously affect orders; around 2% of the liquidity of a token is traded against. A good description of this can be found via this article and most recently here . Different AMMs have variations of this deterministic pricing formula depending on their need. Curve implements a special formula to allow stablecoins trades for assets that are a stable representation of each other, which results in a narrow trading band. An example of this is trading between ETH and sETH (synthetic ETH){target=_blank} or USDC and DAI which should both be pegged close to the US Dollar. Synching Prices Across Markets With Automated Market Makers similar to UniSwap v2, prices are synched with outside markets via arbitrageurs who spot price differences between exchanges. These exchanges can be other DEXes or centralized exchanges. Arbitrageurs capture the profit, which is the difference in price between the two markets. A consequence of this is impermanent loss for liquidity providers, the difference between holding an asset and providing liquidity. This is similar to an opportunity cost which if realized turns into a real loss. Impermanent loss is also described in this animated video and article and here . Uniswap V3 has other features like Range Orders and Limit Orders which you can explore. There are some AMMs that can hold more than two assets, namely Balancer, but these are more sophisticated and rely on Bonding Surfaces . Additional Resources DeFi and the Future of Finance (section 4.7.2) DeFi and the Future of Finance (section 6.2) Graphical Guide for Understanding Uniswap via EthHub","title":"Automated Market Makers - AMM"},{"location":"S05a-defi/M5b-amms/L1/#automated-market-makers-amm","text":"An automated market maker (AMM){target=_blank} is a smart contract that holds assets and is always willing to quote you a price between two assets. You can trade against the AMM\u2019s capital in the smart contract instead of between peers. It uses the trades to update the size of the assets, and update their price accordingly. By raising the price for an asset based demand, the AMM can always guarantee liquidity albeit at higher and higher prices. There are various ones , however we will focus on the most important features popularized by UniSwap. Haseeb Qureshi explains UniSwap well here. We will cover another type of DEX protocol in a later section. This section will give an overview of two key concepts that make AMMs possible.","title":"Automated Market Makers - AMM"},{"location":"S05a-defi/M5b-amms/L1/#liquidity-pools","text":"Automated Market Makers rely on liquidity pools to source capital. Liquidity pools are collections of tokens locked into a smart contract. This allows for decentralized capital formation. They are used to facilitate trading by providing liquidity, defined as the ability to convert an asset into cash or its equivalents without greatly affecting its market price. This is important because an asset's value is determined by what others are willing to pay for it and the ease to which it can be bought or sold. The main ideas behind liquidity pools are: They are used to source capital which is used to provide liquidity. Liquidity is the ability to convert an asset into cash without affecting its price. They are useful because order book models are not feasible on-chain completely since market makers cannot update prices all the time due to gas fees and Ethereum\u2019s throughput being too slow. Liquidity pools source capital from anyone and are used to allow anyone to trade against the smart contract. Liquidity providers earn a fee for doing so in the proportion of capital they provide to the pool. To become a liquidity provider, users must deposit equal amounts of token based on their price into a pool. If they don\u2019t, they risk being arbitraged by traders who find a good deal. -AMMs like UniSwap hold liquidity pools in token pairs. An example can be the ETH - DAI or CRV - COMP (Curve to Compound Finance){target=_blank}. The downside : Because trades happen on-chain, bots can front-run transactions and attempt other sorts of attacks . This results in a user paying more than they intended. Front running occurs when bots read Ethereum's current set of unprocessed pending transactions called the mempool and find an opportunity to outbid a transaction to be processed by the network miner (or validator after ETH 2.0){target=_blank}. The bots cut in front of the line, resulting in a better price for them at the expense of the other trader. -This stems from the Miner Extractable Value , where a miner can dictate when, how and where a transaction will go into a block on Ethereum. When a transaction large enough to create slippage is sent to the network, bots will notice and set off a bidding war to capture the stop and front run.","title":"Liquidity Pools"},{"location":"S05a-defi/M5b-amms/L1/#bonding-curves","text":"The other key to Automated Market Makers is the bonding curve. A b onding curve is a mathematical formula used to describe the relationship between the price and the supply of an asset. This can be thought of as a deterministic pricing formula. This formula is called the Constant Product Formula in UniSwap. This curve can be represented in a smart contract with the ability to buy or sell the underlying token. Bonding Curves emerge out of the ability to escrow funds in a smart contract. The main ideas behind the Constant Product Formula are: -To always ensure liquidity for any asset by modeling the demand curve in the smart contract. Users trade against the smart contract, not between each other. k always has to stay the same number, no matter what x or y does. The price quoted is directly dependent on the size of the order. The trade-off for assured liquidity is slippage, also known as getting less for more. x * y = k x = supply of asset 1 y = supply of asset 2 k = Fixed Size of Pool The downside: Note that the further one moves along the curve, the less they get. In UniSwap, the slippage starts to seriously affect orders; around 2% of the liquidity of a token is traded against. A good description of this can be found via this article and most recently here . Different AMMs have variations of this deterministic pricing formula depending on their need. Curve implements a special formula to allow stablecoins trades for assets that are a stable representation of each other, which results in a narrow trading band. An example of this is trading between ETH and sETH (synthetic ETH){target=_blank} or USDC and DAI which should both be pegged close to the US Dollar.","title":"Bonding Curves"},{"location":"S05a-defi/M5b-amms/L1/#synching-prices-across-markets","text":"With Automated Market Makers similar to UniSwap v2, prices are synched with outside markets via arbitrageurs who spot price differences between exchanges. These exchanges can be other DEXes or centralized exchanges. Arbitrageurs capture the profit, which is the difference in price between the two markets. A consequence of this is impermanent loss for liquidity providers, the difference between holding an asset and providing liquidity. This is similar to an opportunity cost which if realized turns into a real loss. Impermanent loss is also described in this animated video and article and here . Uniswap V3 has other features like Range Orders and Limit Orders which you can explore. There are some AMMs that can hold more than two assets, namely Balancer, but these are more sophisticated and rely on Bonding Surfaces .","title":"Synching Prices Across Markets"},{"location":"S05a-defi/M5b-amms/L1/#additional-resources","text":"DeFi and the Future of Finance (section 4.7.2) DeFi and the Future of Finance (section 6.2) Graphical Guide for Understanding Uniswap via EthHub","title":"Additional Resources"},{"location":"S05a-defi/M5c-rfqs/L1/","text":"Request for Quote When to use which tool Have a large order? Use AirSwap and go deep. It\u2019s great for larger trades to protect margins and protect against a kind of front running called \u201cminer extracted value\u201d . This is because trades are direct between traders, so there is no slippage or public information to the front-run orders. Need liquidity? Use an Automated Market Maker like UniSwap and go wide. It\u2019s great for variety and availability. Ideally, aim for smaller trades to anything under 2% of the total supply of an asset, due to how the \u201cConstant Product Formula\u201d used by AMMs is modelled to ensure liquidity. Key Idea : Use the appropriate tool based on the size of your order. RFQ facilities direct trade between parties which is: Fair - avoids the mempool and issues around Front running, and miner extractable value. Efficient - Eliminates slippage so you get what you paid for. Scalable - negotiations happen off-chain (not on Ethereum){target=_blank} and scales better than relying solely on Ethereum\u2019s throughput. Summary Request for Quote handles trades with off-chain negotiations and on-chain settlement (trades){target=_blank}. Market makers are called Makers who run servers to fulfill orders. Counterparties to makers are called Takers, who wish to trade tokens. RFQ can be seen as peer-to-peer systems. The protocol\u2019s smart contracts focus on on-chain settlement of trades via atomic swaps using smart contracts. Price discovery and negotiation are done off-chain via RPC (remote procedure calls){target=_blank}, which is scalable and resistant to AMM issues related to front running and miner extractable value. This model exists because of Ethereum\u2019s constraints and the issues around large orders on AMMs mentioned previously. Supplying Liquidity Liquidity is provided by Makers who run Servers . These servers are discoverable via the Indexer Protocol which allows for price discovery. Makers submit their prices to trade. Takers are counterparties who wish to start a trade. Instead of talking to each Maker, the Taker sends a request to the Indexer who aggregates the different Makers for Takers. This negotiation is done off-chain via RPC (remote process calls){target=_blank}, making it resistant to flashbots searching the mempool for front run, Miner Extractable Value and other shenanigans. Price Discovery and Verification Makers can consult with Oracles to consider a fair price suggestion. Takers can also consult with Oracles to ensure the price given is a good deal. Liquidity via Delegates If standing up a Server is too much, a Maker could use Delegates . Delegates enable any trader to add rules that specify the size and price for a particular token, which can be used as limit orders. The added benefit is that the trader doesn\u2019t lose custody of their tokens when doing so. The API can be referenced here . Orders and Settlement Once discovery and off-chain negotiation is complete, the orders are settled on-chain. This is done via atomic swaps using the Swaps Contract. They are called atomic because they settle or they don\u2019t. The added benefit of this is that compared to order books, off-chain negotiation makes it more likely that orders will be filled once they are accepted. It helps to eliminate slippage and front running. Note that prior to a Swap, the Validator Contract checks for errors.","title":"Request for Quote"},{"location":"S05a-defi/M5c-rfqs/L1/#request-for-quote","text":"","title":"Request for Quote"},{"location":"S05a-defi/M5c-rfqs/L1/#when-to-use-which-tool","text":"Have a large order? Use AirSwap and go deep. It\u2019s great for larger trades to protect margins and protect against a kind of front running called \u201cminer extracted value\u201d . This is because trades are direct between traders, so there is no slippage or public information to the front-run orders. Need liquidity? Use an Automated Market Maker like UniSwap and go wide. It\u2019s great for variety and availability. Ideally, aim for smaller trades to anything under 2% of the total supply of an asset, due to how the \u201cConstant Product Formula\u201d used by AMMs is modelled to ensure liquidity. Key Idea : Use the appropriate tool based on the size of your order. RFQ facilities direct trade between parties which is: Fair - avoids the mempool and issues around Front running, and miner extractable value. Efficient - Eliminates slippage so you get what you paid for. Scalable - negotiations happen off-chain (not on Ethereum){target=_blank} and scales better than relying solely on Ethereum\u2019s throughput.","title":"When to use which tool"},{"location":"S05a-defi/M5c-rfqs/L1/#summary","text":"Request for Quote handles trades with off-chain negotiations and on-chain settlement (trades){target=_blank}. Market makers are called Makers who run servers to fulfill orders. Counterparties to makers are called Takers, who wish to trade tokens. RFQ can be seen as peer-to-peer systems. The protocol\u2019s smart contracts focus on on-chain settlement of trades via atomic swaps using smart contracts. Price discovery and negotiation are done off-chain via RPC (remote procedure calls){target=_blank}, which is scalable and resistant to AMM issues related to front running and miner extractable value. This model exists because of Ethereum\u2019s constraints and the issues around large orders on AMMs mentioned previously.","title":"Summary"},{"location":"S05a-defi/M5c-rfqs/L1/#supplying-liquidity","text":"Liquidity is provided by Makers who run Servers . These servers are discoverable via the Indexer Protocol which allows for price discovery. Makers submit their prices to trade. Takers are counterparties who wish to start a trade. Instead of talking to each Maker, the Taker sends a request to the Indexer who aggregates the different Makers for Takers. This negotiation is done off-chain via RPC (remote process calls){target=_blank}, making it resistant to flashbots searching the mempool for front run, Miner Extractable Value and other shenanigans.","title":"Supplying Liquidity"},{"location":"S05a-defi/M5c-rfqs/L1/#price-discovery-and-verification","text":"Makers can consult with Oracles to consider a fair price suggestion. Takers can also consult with Oracles to ensure the price given is a good deal.","title":"Price Discovery and Verification"},{"location":"S05a-defi/M5c-rfqs/L1/#liquidity-via-delegates","text":"If standing up a Server is too much, a Maker could use Delegates . Delegates enable any trader to add rules that specify the size and price for a particular token, which can be used as limit orders. The added benefit is that the trader doesn\u2019t lose custody of their tokens when doing so. The API can be referenced here .","title":"Liquidity via Delegates"},{"location":"S05a-defi/M5c-rfqs/L1/#orders-and-settlement","text":"Once discovery and off-chain negotiation is complete, the orders are settled on-chain. This is done via atomic swaps using the Swaps Contract. They are called atomic because they settle or they don\u2019t. The added benefit of this is that compared to order books, off-chain negotiation makes it more likely that orders will be filled once they are accepted. It helps to eliminate slippage and front running. Note that prior to a Swap, the Validator Contract checks for errors.","title":"Orders and Settlement"},{"location":"S05a-defi/M6-oracles/L1/","text":"","title":"Index"},{"location":"S05a-defi/M7-defi-lending/L1/","text":"","title":"Index"},{"location":"S05a-defi/M8-governance/L1/","text":"What are Governance Tokens Decentralized networks have no central entity to manage them. Governance tokens were created to help the community steer the network . Governance tokens represent a percentage of voting power, called \u201cpro-rata voting rights\u201d, over a protocol or network. These tokens typically have code that embeds rules related to how the system can change, like adjusting configurations or adding new components. The ability to adjust a network is essential because DeFi protocols need to stay in sync and react to changing market conditions. It also allows the network to evolve as the ecosystem matures. Examples of governance tokens include Yearn.finance YFI, Compound Finance COMP, UniSwap UNI, AirSwap AST. Due to their influence over a network, they are able to accrue value and are traded on exchanges. Governance tokens rely on incentives to encourage or discourage certain behaviors which maintain network security, solvency and growth. Incentives are powerful tools . Through the use of code to enforce, promote and punish certain behaviors blockchain based systems from the base layer to DeFi protocols layer can create stability and promote coordination absent a central authority. Properly designed incentives can reward early supporters and the initial development team . Or they can result in pump and dumps. Designing these incentives requires good Tokenomics. Tokenomics deals with the management of token economies, including token creation, removal, and applied network incentives. These incentives are best seen at work in treasury management, which deals with the network\u2019s supply of tokens. Tokenomics is not to be confused with CryptoEconomics or the use of economic incentives to provide guarantees about applications in open and adversarial networks. Tokenomics is about coordinating participants, while CryptoEconomics focuses on securing the underlying system . A token\u2019s policy could be inflationary, deflationary or static. Inflationary policies increase the number of tokens through minting. Deflation reduces tokens through burning tokens. Static policies keep them the same. The policies can be used to encourage different actions. Inflation can be used to bootstrap a network by compensating users for activities to achieve utility, network participants and liquidity. As long as the network\u2019s utility is greater than the inflation rate, it could make sense to increase the supply. This could be measured by many indicators like network activity and the price for the token. Treasury management is deeply linked to community management, since how you incentivize and manage tokens leads to community engagement. An application of this are liquidity mining programs. These provide staking rewards as a positive incentive for users to provide liquidity to a network. Users are credited with a bonus in their token account, based on their stake. They function as a marketing expense to bootstrap networks. Airdrops are another popular form of distribution, the most famous being UniSwap to retain liquidity from being sucked away by competing platforms. Pioneered by Compound.finance , users were rewarded by engaging in certain behaviors and received tokens which could be used for governance. This model was copied by others and led to the DeFi Summer of 2020. Seeking a return from these tokens led to yield farming , the activity of moving assets between protocols to gain a maximum return. There are also incentives to discourage negative behavior like slashing funds for certain actions or liquidations for undercollateralized positions. Further incentives include direct rewards where users can be paid for providing liquidity to a pool and earn a fee in proportion to the amount staked. Not all DeFi protocols or blockchain applications are decentralized. If a protocol\u2019s governance can be centralized if it\u2019s only controlled by the admins. True decentralization implies decentralized infrastructure and governance. Governance token holders exercise their influence via DAOs, short for decentralized autonomous organizations. They can be airdropped to users of a platform to transition to a DAO like Shapeshift did in July 2021 . We will cover DAOs in a later section. Additional Resources Compound Governance Contracts Walkthrough Governance and Voting {target=_blank}","title":"What are Governance Tokens"},{"location":"S05a-defi/M8-governance/L1/#what-are-governance-tokens","text":"Decentralized networks have no central entity to manage them. Governance tokens were created to help the community steer the network . Governance tokens represent a percentage of voting power, called \u201cpro-rata voting rights\u201d, over a protocol or network. These tokens typically have code that embeds rules related to how the system can change, like adjusting configurations or adding new components. The ability to adjust a network is essential because DeFi protocols need to stay in sync and react to changing market conditions. It also allows the network to evolve as the ecosystem matures. Examples of governance tokens include Yearn.finance YFI, Compound Finance COMP, UniSwap UNI, AirSwap AST. Due to their influence over a network, they are able to accrue value and are traded on exchanges. Governance tokens rely on incentives to encourage or discourage certain behaviors which maintain network security, solvency and growth. Incentives are powerful tools . Through the use of code to enforce, promote and punish certain behaviors blockchain based systems from the base layer to DeFi protocols layer can create stability and promote coordination absent a central authority. Properly designed incentives can reward early supporters and the initial development team . Or they can result in pump and dumps. Designing these incentives requires good Tokenomics. Tokenomics deals with the management of token economies, including token creation, removal, and applied network incentives. These incentives are best seen at work in treasury management, which deals with the network\u2019s supply of tokens. Tokenomics is not to be confused with CryptoEconomics or the use of economic incentives to provide guarantees about applications in open and adversarial networks. Tokenomics is about coordinating participants, while CryptoEconomics focuses on securing the underlying system . A token\u2019s policy could be inflationary, deflationary or static. Inflationary policies increase the number of tokens through minting. Deflation reduces tokens through burning tokens. Static policies keep them the same. The policies can be used to encourage different actions. Inflation can be used to bootstrap a network by compensating users for activities to achieve utility, network participants and liquidity. As long as the network\u2019s utility is greater than the inflation rate, it could make sense to increase the supply. This could be measured by many indicators like network activity and the price for the token. Treasury management is deeply linked to community management, since how you incentivize and manage tokens leads to community engagement. An application of this are liquidity mining programs. These provide staking rewards as a positive incentive for users to provide liquidity to a network. Users are credited with a bonus in their token account, based on their stake. They function as a marketing expense to bootstrap networks. Airdrops are another popular form of distribution, the most famous being UniSwap to retain liquidity from being sucked away by competing platforms. Pioneered by Compound.finance , users were rewarded by engaging in certain behaviors and received tokens which could be used for governance. This model was copied by others and led to the DeFi Summer of 2020. Seeking a return from these tokens led to yield farming , the activity of moving assets between protocols to gain a maximum return. There are also incentives to discourage negative behavior like slashing funds for certain actions or liquidations for undercollateralized positions. Further incentives include direct rewards where users can be paid for providing liquidity to a pool and earn a fee in proportion to the amount staked. Not all DeFi protocols or blockchain applications are decentralized. If a protocol\u2019s governance can be centralized if it\u2019s only controlled by the admins. True decentralization implies decentralized infrastructure and governance. Governance token holders exercise their influence via DAOs, short for decentralized autonomous organizations. They can be airdropped to users of a platform to transition to a DAO like Shapeshift did in July 2021 . We will cover DAOs in a later section.","title":"What are Governance Tokens"},{"location":"S05a-defi/M8-governance/L1/#additional-resources","text":"Compound Governance Contracts Walkthrough Governance and Voting {target=_blank}","title":"Additional Resources"},{"location":"S05a-defi/M9-swaps/L1/","text":"Introduction to MetaMask Swaps In the previous section, we covered decentralized exchanges and briefly touched upon aggregators, which finds the best price between exchanges. We can go a step further and have aggregators of aggregators. The most popular aggregator of aggregators is MetaMask Swaps. MetaMask Swaps addresess five issues 1 | Barrier to entry is high Before interacting with different defi protocols, users must first familiarize themselves with those platforms and understand the pros-and-cons of each. 2 | Rates vary between protocols Not all liquidity sources (DEX, DEX aggregators, and PMMs) are created equal. The rate that each protocol provides may depend on liquidity depth, pricing mechanism, and type of tokens. 3 | Gas usage differs between sources The route and complexity of each Swap may differ, depending on the liquidity source. Some sources will require less gas, depending on the route. 4 | Liquidity is fragmented Decentralization leads to liquidity fragmentation. For some trades, splitting a Swap between multiple sources can result in the most favorable trade. 5 | Token approvals are messy and expensive When Swapping ERC20 tokens, users must first approve individual tokens on each liquidity source. MetaMask Swaps solves these issues with three things 1 | Best rates across DeFi By requesting prices from all available DEXs, DEX aggregators, and individual market makers, we can guarantee that MetaMask users have access to the deepest liquidity, largest selection of tokens, and the most competitive prices. 2 | Seamless and standardized UX We\u2019ve abstracted all the complexities, allowing MetaMask users to Swap > 1,000 unique tokens in three clicks. 3 | Approve once, Swap anywhere No need to approve every token on multiple DEXs and aggregators for each trade. With Swaps, users only need to approve each token once, reducing gas costs and shortening the path to executing their trade.","title":"Introduction to MetaMask Swaps"},{"location":"S05a-defi/M9-swaps/L1/#introduction-to-metamask-swaps","text":"In the previous section, we covered decentralized exchanges and briefly touched upon aggregators, which finds the best price between exchanges. We can go a step further and have aggregators of aggregators. The most popular aggregator of aggregators is MetaMask Swaps.","title":"Introduction to MetaMask Swaps"},{"location":"S05a-defi/M9-swaps/L1/#metamask-swaps-addresess-five-issues","text":"","title":"MetaMask Swaps addresess five issues"},{"location":"S05a-defi/M9-swaps/L1/#1-barrier-to-entry-is-high","text":"Before interacting with different defi protocols, users must first familiarize themselves with those platforms and understand the pros-and-cons of each.","title":"1 | Barrier to entry is high"},{"location":"S05a-defi/M9-swaps/L1/#2-rates-vary-between-protocols","text":"Not all liquidity sources (DEX, DEX aggregators, and PMMs) are created equal. The rate that each protocol provides may depend on liquidity depth, pricing mechanism, and type of tokens.","title":"2 | Rates vary between protocols"},{"location":"S05a-defi/M9-swaps/L1/#3-gas-usage-differs-between-sources","text":"The route and complexity of each Swap may differ, depending on the liquidity source. Some sources will require less gas, depending on the route.","title":"3 | Gas usage differs between sources"},{"location":"S05a-defi/M9-swaps/L1/#4-liquidity-is-fragmented","text":"Decentralization leads to liquidity fragmentation. For some trades, splitting a Swap between multiple sources can result in the most favorable trade.","title":"4 | Liquidity is fragmented"},{"location":"S05a-defi/M9-swaps/L1/#5-token-approvals-are-messy-and-expensive","text":"When Swapping ERC20 tokens, users must first approve individual tokens on each liquidity source.","title":"5 | Token approvals are messy and expensive"},{"location":"S05a-defi/M9-swaps/L1/#metamask-swaps-solves-these-issues-with-three-things","text":"","title":"MetaMask Swaps solves these issues with three things"},{"location":"S05a-defi/M9-swaps/L1/#1-best-rates-across-defi","text":"By requesting prices from all available DEXs, DEX aggregators, and individual market makers, we can guarantee that MetaMask users have access to the deepest liquidity, largest selection of tokens, and the most competitive prices.","title":"1 | Best rates across DeFi"},{"location":"S05a-defi/M9-swaps/L1/#2-seamless-and-standardized-ux","text":"We\u2019ve abstracted all the complexities, allowing MetaMask users to Swap > 1,000 unique tokens in three clicks.","title":"2 | Seamless and standardized UX"},{"location":"S05a-defi/M9-swaps/L1/#3-approve-once-swap-anywhere","text":"No need to approve every token on multiple DEXs and aggregators for each trade. With Swaps, users only need to approve each token once, reducing gas costs and shortening the path to executing their trade.","title":"3 | Approve once, Swap anywhere"},{"location":"S08-scalability/M1-intro/L1-overview/","text":"Intro to Scalability Ethereum gas fees have risen astronomically as the network becomes more popular. The ability of retail investors to participate in new Ethereum-based offerings like DeFi is circumscribed by the ever-increasing cost of entry into the space. Three main challenges presented by the success of mainnet Ethereum: 1. Spiking gas costs price-out market share and impact user experience. Best case is loss of low-value transactions and poor UX due to stuck transactions. Worst case is compromising healthy market operation like Black Thursday. 2. Block Latency is problematic in some applications 3. Pushing gas costs to users creates friction and impacts user experience. User has to navigate rather complex effects. As a result, some users and products are migrating to other chains that offer lower costs. Off-chain scaling is capable of solving these problems by providing higher throughput, faster state advancement and gas cost abstraction. It can be transformative for application UX State advancement (propagating new network state) is 10-100x faster (the rate at which data can be updated on-chain). Reducing user feedback loop from 12s to <1s. High frequency transactions possible (e.g. high-fidelity price oracles, rapid orderbook management) Transactions are a fraction of the cost. Low or no-value transactions viable Support for native gas cost abstraction, meta-transactions, account abstraction. Subsidised gas, or gas cost is paid in relevant tokens. Better native support for smart contract wallets and features like social recovery. If Ethereum is to maintain its dominance and network effect, it must scale. Terminology In the following sections, we're first going to go through some of the types of Layer 2 solutions. Then walk through examples of popular Layer 2 solutions. We're then going to talk about crosschain and blockchain interoperability. Finally, we're going to have live sessions and presentations based around L2 platforms such as Polygon, Optimism and more. In this section, we'll typically refer to mainnet Ethereum as Layer 1 or L1 and whatever the scaling solution is as a Layer 2 solution (L2), a sidechain, sidechannel or a bridge. Conclusion These are exciting and very new topics, please be aware that they are considered very cutting edge and you should be extremely careful when using them. Also, please know that the documentation changes very regularly and perhaps not perceptibly. If you're currently building on a Layer 2 solution, we recommend joining the project's Discord, or wherever the community gathers, and making sure to follow their developer updates. Let's dive in!","title":"Intro to Scalability"},{"location":"S08-scalability/M1-intro/L1-overview/#intro-to-scalability","text":"Ethereum gas fees have risen astronomically as the network becomes more popular. The ability of retail investors to participate in new Ethereum-based offerings like DeFi is circumscribed by the ever-increasing cost of entry into the space. Three main challenges presented by the success of mainnet Ethereum: 1. Spiking gas costs price-out market share and impact user experience. Best case is loss of low-value transactions and poor UX due to stuck transactions. Worst case is compromising healthy market operation like Black Thursday. 2. Block Latency is problematic in some applications 3. Pushing gas costs to users creates friction and impacts user experience. User has to navigate rather complex effects. As a result, some users and products are migrating to other chains that offer lower costs. Off-chain scaling is capable of solving these problems by providing higher throughput, faster state advancement and gas cost abstraction. It can be transformative for application UX State advancement (propagating new network state) is 10-100x faster (the rate at which data can be updated on-chain). Reducing user feedback loop from 12s to <1s. High frequency transactions possible (e.g. high-fidelity price oracles, rapid orderbook management) Transactions are a fraction of the cost. Low or no-value transactions viable Support for native gas cost abstraction, meta-transactions, account abstraction. Subsidised gas, or gas cost is paid in relevant tokens. Better native support for smart contract wallets and features like social recovery. If Ethereum is to maintain its dominance and network effect, it must scale.","title":"Intro to Scalability"},{"location":"S08-scalability/M1-intro/L1-overview/#terminology","text":"In the following sections, we're first going to go through some of the types of Layer 2 solutions. Then walk through examples of popular Layer 2 solutions. We're then going to talk about crosschain and blockchain interoperability. Finally, we're going to have live sessions and presentations based around L2 platforms such as Polygon, Optimism and more. In this section, we'll typically refer to mainnet Ethereum as Layer 1 or L1 and whatever the scaling solution is as a Layer 2 solution (L2), a sidechain, sidechannel or a bridge.","title":"Terminology"},{"location":"S08-scalability/M1-intro/L1-overview/#conclusion","text":"These are exciting and very new topics, please be aware that they are considered very cutting edge and you should be extremely careful when using them. Also, please know that the documentation changes very regularly and perhaps not perceptibly. If you're currently building on a Layer 2 solution, we recommend joining the project's Discord, or wherever the community gathers, and making sure to follow their developer updates. Let's dive in!","title":"Conclusion"},{"location":"S08-scalability/M2-types/L1/","text":"Types of Scaling Solutions Several options have been proposed and worked on for scaling Ethereum on a shorter time frame. Some of these efforts are coming to fruition now and are worth considering. The main tradeoffs for choosing a scaling solution involve considerations of throughput vs. security vs. usability . The following are some solutions currently in the works at various stages: Note: This section draws heavily on the work on Faina Shalts, engineer at Truffle (and Bootcamp alumni!) as well as from Ethereum.org Rollups In general, on Rollup Layer 2 solutions, transactions are submitted to L2 nodes instead of L1, and batched. Eventually they are put on L1 and no longer mutable. L2 nodes are Ethereum compatible, independent blockchains. All state and execution is handled in L2: Signature verification, Contract execution, etc. The L1 only stores transaction data Note: the terminology here can be challenging but Pranay Mohan of Celo Network proposes we think of rollups as shard clients and the rollup contracts as on-chain light clients. There are two major kinds of Rollups: ZK-Rollups and Optimistic Rollups. Zero-Knowledge / ZK-Rollups As we mentioned earlier in the section on Zero-Knowledge proofs, ZKPs can compress a larger amount of computation or verificatio into a single operation. ZK-Rollups bundle hundreds of transfers that occur on the ZKP Rollup L2 into a single L1, mainnet transaction via a smart contract located on L1. From the data submitted the smart contract can verify all the transfers that are included. Critically, you don\u2019t need all the data to verify the transactions, just the zero-knowledge proof. Transactions are written to Ethereum as calldata, to reduce gas. Pros No delay, less vulnerable to economic attacks Cons Limited to simple transfers and ZK-Rollup chains not compatible with EVM as validity proofs are intense to compute and have to build their own language to process. ZK-Rollups are not worth it for applications with little on-chain activity but are attractive for simple, high-volume exchanges. Currently using this sort of rollup: Loopring , Starkware, Matter Labs' zkSync, Aztec's ZK.Money network Optimistic Rollups Optimistic Rollups use a sidechain that sits in parallel to the mainnet Ethereum chain. They don\u2019t do any computation by default: after a transaction, the Optimistic Rollup L2s proposes a new state to the L1 mainnet, or \u201cnotarizes\u201d the transaction. L2 Transactions written to L1 mainnet as calldata . The main mechanism that makes this work are fraud proofs: If someone notices a fraudulent transaction the Optimistic Rollup network will execute a fraud-proof and run the transaction\u2019s computation using the available state data; the gas you need to run a fraud proof is reimbursed. Pros Anything you can do on L1 you can do with Optimistic Rollups because it is EVM and Solidity compatible. All transaction data is stored on the L1 chain, meaning it remains secure and decentralized. Cons Long wait times for on-chain transactions due to potential fraud challenges. Potentially vulnerable to attacks if the value in an optimistic rollup exceeds the amount in an operator\u2019s bond. Optimistic Roll-ups are currently being built by Optimistic PBC, Arbitrum, Fuel Network, ImmutableX, Deversifi and Cartesi Channels Channels, also called Side Channels or State Channels, allow participants to transact a certain number of times off-chain (on the channel) while only submitting 2 transactions to the network on chain (basically, the start and stop of the channel). Fundamentally for a channel to exist, participants must lock a portion of Ethereum\u2019s state, like an ETH deposit, in a multisig contract. Locking state in this way opens up the channel, allowing for the off-chain transactions to occur. When the interaction is finished, one final L1 transaction is submitted, updating the network state based on the activity that occurred on the channel (mainly the rebalancing of funds between the participants). Sidenote: State channels on Ethereum can be enforced through a concept known as counterfactual instantiation. Here's a technical, but concise, overview of counterfactual instantiation: Counterfactual instantiation is achieved by making users sign and share commitments to the multisig wallet. These commitments say that if the counterfactually instantiated contract were to be instantiated on-chain, the multisig wallet (which holds the state deposit) will look at the instantiated contract and transfer the appropriate state deposits based on the state of that contract. On Ethereum, you can use the CREATE2 opcode to predetermine the address of a contract. This means you can make these commitments in a channel and, if you need to dispute something, either party can deploy that contract with the chain of valid commitments. State Channel pros and cons (from Ethereum.org ): - Pros Instant withdrawal/settling on mainnet, high throughput, lower cost per transaction - Cons Time and cost to set up and settle a channel. Funds must be locked up, participants need to periodically watch the network. Channels don\u2019t support open participation. Examples of state channels are Connext, Raiden Network, and Bitcoin's Lightning Network. Sidechains The terminology here can get a little tricky, so bear with us. Sidechains are essentially blockchain networks separate from your Layer 1 (for us, Ethereum). They are connected through a bridge, which allows state to be conveyed from one chain to the other. We'll discuss this more in the crosschain and interoperability section, but essentially you'd use a chain that either has a consensus mechanism with a higher trust assumption (such as Proof of Authority) or some increased transaction throughput relative to your Layer 1. You would then be able to conduct transactions on that sidechain and, when you need to update the state (perhaps a user wishes to exit your network but wants to take their tokens), you can release it on your Layer 1. Examples of sidechains are SKALE and xDai. Conclusion This concludes our overview of the kinds of scaling solutions available to us. It is by no means comprehensive, since the field is rapidly evolving. In the next section, we'll provide a basic rubric by which you can judge any Layer 2 or general scaling solution. Additional Material Wiki: Scaling (Ethereum.org) Great overview of the topic, including the \"pros and cons\" of different solutions Video: Layer 2 Scaling Explained (Finematics) Slide Deck: Scaling Ethereum using Rollups and Sidechains From the Engineering Ethereum meetup and presented by Peter Robinson. Article: Maker's roadmap for L2s Discusses one major application's understanding and strategy for Layer 2 solutions. Article: A Note on Bridges & Layer 2 Protocols (Patrick McCorry) A discussion around different sorts of bridge technologies and considerations we should have when using them. Video: How Layer 2 Addresses Barriers for Enterprise Building on Mainnet Rollups Article: An Incomplete Guide to Rollups (Vitalik Buterin) A follow-up article to Buterin's post on eth.research entitled, \"What would a rollup-centric ethereum roadmap look like?\" and here's a video version of the article. Research: Compressing Data Using Rollups A technical discussions around optimizing data compression for Rollups Thread: Rollup verification A great walkthrough about how rollups conduct verification and how that verification can make it to Layer 1 Article: (Almost) Everything You Need to Know About Optimistic Rollup (Paradigm) Really good technical overview of optimistic rollup tech Artilce: Arbitrum in under 10 minutes An explainer of Arbitrum, an optimistic rollup. State Channels Article: State Channel Basics Article: Generalized State Channels on Ethereum Goes into more detail about counterfactual instantiation. Article: State Channels Basic overview of the technology from 2015. Good evergreen concepts here. Article Series: A State Channels Adventure A potentially NSFW walkthrough of the physics behind counterfactual instantiation. Tutorial: Precompute Contract Addresses with CREATE2 A great code tutorial from Solidity by Example showing how to find a predetermined address for a contract, the backbone of counterfactual instantiation. Code Demo: Web3 Torrent A Proof of Concept from StateChannels.org, a torrenting network built using state channels (or a subset of state channels they call virtual channels ).","title":"Types of Scaling Solutions"},{"location":"S08-scalability/M2-types/L1/#types-of-scaling-solutions","text":"Several options have been proposed and worked on for scaling Ethereum on a shorter time frame. Some of these efforts are coming to fruition now and are worth considering. The main tradeoffs for choosing a scaling solution involve considerations of throughput vs. security vs. usability . The following are some solutions currently in the works at various stages: Note: This section draws heavily on the work on Faina Shalts, engineer at Truffle (and Bootcamp alumni!) as well as from Ethereum.org","title":"Types of Scaling Solutions"},{"location":"S08-scalability/M2-types/L1/#rollups","text":"In general, on Rollup Layer 2 solutions, transactions are submitted to L2 nodes instead of L1, and batched. Eventually they are put on L1 and no longer mutable. L2 nodes are Ethereum compatible, independent blockchains. All state and execution is handled in L2: Signature verification, Contract execution, etc. The L1 only stores transaction data Note: the terminology here can be challenging but Pranay Mohan of Celo Network proposes we think of rollups as shard clients and the rollup contracts as on-chain light clients. There are two major kinds of Rollups: ZK-Rollups and Optimistic Rollups.","title":"Rollups"},{"location":"S08-scalability/M2-types/L1/#zero-knowledge-zk-rollups","text":"As we mentioned earlier in the section on Zero-Knowledge proofs, ZKPs can compress a larger amount of computation or verificatio into a single operation. ZK-Rollups bundle hundreds of transfers that occur on the ZKP Rollup L2 into a single L1, mainnet transaction via a smart contract located on L1. From the data submitted the smart contract can verify all the transfers that are included. Critically, you don\u2019t need all the data to verify the transactions, just the zero-knowledge proof. Transactions are written to Ethereum as calldata, to reduce gas. Pros No delay, less vulnerable to economic attacks Cons Limited to simple transfers and ZK-Rollup chains not compatible with EVM as validity proofs are intense to compute and have to build their own language to process. ZK-Rollups are not worth it for applications with little on-chain activity but are attractive for simple, high-volume exchanges. Currently using this sort of rollup: Loopring , Starkware, Matter Labs' zkSync, Aztec's ZK.Money network","title":"Zero-Knowledge / ZK-Rollups"},{"location":"S08-scalability/M2-types/L1/#optimistic-rollups","text":"Optimistic Rollups use a sidechain that sits in parallel to the mainnet Ethereum chain. They don\u2019t do any computation by default: after a transaction, the Optimistic Rollup L2s proposes a new state to the L1 mainnet, or \u201cnotarizes\u201d the transaction. L2 Transactions written to L1 mainnet as calldata . The main mechanism that makes this work are fraud proofs: If someone notices a fraudulent transaction the Optimistic Rollup network will execute a fraud-proof and run the transaction\u2019s computation using the available state data; the gas you need to run a fraud proof is reimbursed. Pros Anything you can do on L1 you can do with Optimistic Rollups because it is EVM and Solidity compatible. All transaction data is stored on the L1 chain, meaning it remains secure and decentralized. Cons Long wait times for on-chain transactions due to potential fraud challenges. Potentially vulnerable to attacks if the value in an optimistic rollup exceeds the amount in an operator\u2019s bond. Optimistic Roll-ups are currently being built by Optimistic PBC, Arbitrum, Fuel Network, ImmutableX, Deversifi and Cartesi","title":"Optimistic Rollups"},{"location":"S08-scalability/M2-types/L1/#channels","text":"Channels, also called Side Channels or State Channels, allow participants to transact a certain number of times off-chain (on the channel) while only submitting 2 transactions to the network on chain (basically, the start and stop of the channel). Fundamentally for a channel to exist, participants must lock a portion of Ethereum\u2019s state, like an ETH deposit, in a multisig contract. Locking state in this way opens up the channel, allowing for the off-chain transactions to occur. When the interaction is finished, one final L1 transaction is submitted, updating the network state based on the activity that occurred on the channel (mainly the rebalancing of funds between the participants). Sidenote: State channels on Ethereum can be enforced through a concept known as counterfactual instantiation. Here's a technical, but concise, overview of counterfactual instantiation: Counterfactual instantiation is achieved by making users sign and share commitments to the multisig wallet. These commitments say that if the counterfactually instantiated contract were to be instantiated on-chain, the multisig wallet (which holds the state deposit) will look at the instantiated contract and transfer the appropriate state deposits based on the state of that contract. On Ethereum, you can use the CREATE2 opcode to predetermine the address of a contract. This means you can make these commitments in a channel and, if you need to dispute something, either party can deploy that contract with the chain of valid commitments. State Channel pros and cons (from Ethereum.org ): - Pros Instant withdrawal/settling on mainnet, high throughput, lower cost per transaction - Cons Time and cost to set up and settle a channel. Funds must be locked up, participants need to periodically watch the network. Channels don\u2019t support open participation. Examples of state channels are Connext, Raiden Network, and Bitcoin's Lightning Network.","title":"Channels"},{"location":"S08-scalability/M2-types/L1/#sidechains","text":"The terminology here can get a little tricky, so bear with us. Sidechains are essentially blockchain networks separate from your Layer 1 (for us, Ethereum). They are connected through a bridge, which allows state to be conveyed from one chain to the other. We'll discuss this more in the crosschain and interoperability section, but essentially you'd use a chain that either has a consensus mechanism with a higher trust assumption (such as Proof of Authority) or some increased transaction throughput relative to your Layer 1. You would then be able to conduct transactions on that sidechain and, when you need to update the state (perhaps a user wishes to exit your network but wants to take their tokens), you can release it on your Layer 1. Examples of sidechains are SKALE and xDai.","title":"Sidechains"},{"location":"S08-scalability/M2-types/L1/#conclusion","text":"This concludes our overview of the kinds of scaling solutions available to us. It is by no means comprehensive, since the field is rapidly evolving. In the next section, we'll provide a basic rubric by which you can judge any Layer 2 or general scaling solution.","title":"Conclusion"},{"location":"S08-scalability/M2-types/L1/#additional-material","text":"Wiki: Scaling (Ethereum.org) Great overview of the topic, including the \"pros and cons\" of different solutions Video: Layer 2 Scaling Explained (Finematics) Slide Deck: Scaling Ethereum using Rollups and Sidechains From the Engineering Ethereum meetup and presented by Peter Robinson. Article: Maker's roadmap for L2s Discusses one major application's understanding and strategy for Layer 2 solutions. Article: A Note on Bridges & Layer 2 Protocols (Patrick McCorry) A discussion around different sorts of bridge technologies and considerations we should have when using them. Video: How Layer 2 Addresses Barriers for Enterprise Building on Mainnet","title":"Additional Material"},{"location":"S08-scalability/M2-types/L1/#rollups_1","text":"Article: An Incomplete Guide to Rollups (Vitalik Buterin) A follow-up article to Buterin's post on eth.research entitled, \"What would a rollup-centric ethereum roadmap look like?\" and here's a video version of the article. Research: Compressing Data Using Rollups A technical discussions around optimizing data compression for Rollups Thread: Rollup verification A great walkthrough about how rollups conduct verification and how that verification can make it to Layer 1 Article: (Almost) Everything You Need to Know About Optimistic Rollup (Paradigm) Really good technical overview of optimistic rollup tech Artilce: Arbitrum in under 10 minutes An explainer of Arbitrum, an optimistic rollup.","title":"Rollups"},{"location":"S08-scalability/M2-types/L1/#state-channels","text":"Article: State Channel Basics Article: Generalized State Channels on Ethereum Goes into more detail about counterfactual instantiation. Article: State Channels Basic overview of the technology from 2015. Good evergreen concepts here. Article Series: A State Channels Adventure A potentially NSFW walkthrough of the physics behind counterfactual instantiation. Tutorial: Precompute Contract Addresses with CREATE2 A great code tutorial from Solidity by Example showing how to find a predetermined address for a contract, the backbone of counterfactual instantiation. Code Demo: Web3 Torrent A Proof of Concept from StateChannels.org, a torrenting network built using state channels (or a subset of state channels they call virtual channels ).","title":"State Channels"},{"location":"S08-scalability/M3-rubric/L1/","text":"Rubric for Analyzing Scalability Solutions The challenge with understanding Layer 2 and scaling solutions is a common challenge for The explosion in demand for sophisticated, bleeding-edge cryptographic products leads to a common predicament in blockchain. For those not deeply familiar with these projects and their associated tech, it\u2019s extremely difficult\u2014if not intimidating\u2014to decide which is best and safest to use. Not to mention the rate of change of L2 documentation and the L2 frameworks themselves. However, there are trade-offs to using scalability solutions. Trade-offs to the blockchain primitives we discussed earlier in the course. With this section, we will continue propose a framework to assist the analysis of L2 projects. It\u2019s meant to help the reader develop an intuition for approaching a possible L2 solution for their various needs and circumstances. But it's also meant to highlight the trade-offs a scalability approach requires against our main blockchain network layer. This framework has eight assessment variables ( Operator , Data Availability , Computational Integrity , Economic Security , Stack Security , Capital Efficiency , Transaction Finality , and Programmability ). We use these assessment variables to score a project in three areas: Throughput , Security and Usability . See how the variables contribute to each area below: To be clear, these variables are not exhaustive. We haven\u2019t included network costs, users costs or the downstream network effects a Layer 2 inherits from the underlying Layer 1 blockchain. Again, the idea of the framework is not necessarily to be comprehensive but rather help develop an intuition for the benefits and trade-offs of different L2 solutions. Be sure to keep in mind the mental model around distributed consensus we learned earlier, it will come in handy. You can understand this lesson as a deeper development of the roles and features we discussed there. L2 Operator An Operator describes an actor within the L2 system responsible for executing state change within the L2 network. This includes facilitating entrances and exits to the L2 system as well as processing and authorizing transactions within the L2 system. Some considerations when analyzing an operator: - Is an Operator required in the L2 network? - Understanding Their Role: Who or what is the operator? What is the Operator responsible for? What is the motivation to become an Operator? - Trust Assumptions: Who can become an Operator? What power does an Operator have? What consensus rules do they abide by? What trust assumptions must users make about the Operator? - Risk Exposure: After answering the above questions, what risks do we need to consider? For example, how does the network respond when an Operator disappears, misbehaves. How does the system respond to L1 attacks or mass exit? Computational Integrity Computational Integrity (CI) is a key property of network security. CI seeks to ensure that the code for a given computation runs exactly as intended and therefore the state transition outputs are correct. Let\u2019s unpack this. The operation of each state advancement in a network can be simplified to: CI ensures that the data in the network is correct, because the code that advances the state of the network has run correctly and without manipulation by the operator actually performing the computation. It is enforced through two primary methods: Crypto-Economic Incentives This could take the form of incentivised consensus where the network can only advance if all network participants run and post the same computation resulting in a critical mass of agreement. It could also take the form of incentivised watchtowers where the network trusts third-parties to verify CI from operators and, in the case of misbehavior, trigger a network failsafe. Zero-Knowledge Cryptography Building mathematical assurances into the network\u2019s code execution model making integrity provable and verifiable Data Availability This refers to the availability and immutability of intermediary state transition data. To go back to our state advancement of the network diagram: State transition data is a list of all intermediary state changes, alongside proof they are valid (e.g. aggregate signatures, ZKPs). Once a user\u2019s assets enter a L2, they are subject to the security properties of the L2, and therefore data availability is key to being able to verify that what happens to the user\u2019s assets within the L2 is valid and correct. Economic Security Economic Security refers to the operational security that upholds the financial integrity of the L2 system. It can be rooted in two different areas: Inherited Economic Security from L1 This can be a strong inheritance where L2 assets are ultimately secured in contracts on L1 and L2 state transitions are checkpointed on L1. It can also be a weak inheritance, where L2 assets are ultimately secured on L1, but computational integrity and data availability are not secured by L1 Security Inherent to the Operator The characteristics of the L2 Operators may lend additional security, for example in Proof of Stake. Keep in mind, consensus methods such as Proof of Authority lend no inherent security beyond basic trust in the Operators. Stack Security Stack Security is more of a passive security that comes from having a battle-hardened software stack. It includes aspects like: Shared Cryptographic Primitives Or primitives developed and hardened over decades of research and application. Compare this with newer cryptographic features that may not currently enjoy widespread adoption. For example, Elliptic Curve Cryptography versus newer ZKP methods. Shared Technology Stack Shared Investments into core technology stack and open-source network effects. Examples include the Go-Ethereum implementation, Solidity compiler and EVM runtime maintained by hundreds of contributors over time. Shared Ancillary Tooling Mature development environments and workflows, such as Truffle as well as security tooling, such as EVM bytecode formal verification, Solidity static analysis and fuzzers. Shared ecosystem and aligned security objectives The powerful network effects delivered by open-source development and the community that forms around it. Includes security gathered from audits, formal verification development, and institutional knowledge of attack vectors and history. Capital Efficiency This refers to the cost and utility of capital held in an L2 network over time. L2 capital efficiency points that should be considered include: Capital must be locked into an L1 contract in order to move into the L2 Locking capital can come at high opportunity cost depending on the lockup times. Some systems require a lockup time of minutes, others require weeks. The real cost of capital can be discounted depending on the utility available within the network If the user can access great utility, the opportunity costs of lockup can be lower even if their capital is locked up. Fees for rapid exits, facilitated by liquidity providers (LPs), will be determined by real cost of capital. We'll discuss this more in our live session, \"Problems Still to Be Solved in Scalability.\" Transaction Finality Transaction finality on L1s is essentially full redeemability of assets. For L2s, there are multiple phases of finality: Operator finality, Checkpoint finality and L1 finality. The relationship of these three within a generic L2 is shown below: A user submitting a transaction within an L2 gets near-instantaneous finality when their transaction has been processed by an Operator. The user does not necessarily have to wait for L1 redeemability, rather they can use the Operator Finality as proof to exit via a Liquidity Provider. The Operator periodically submits a batch of L2 transactions and the subsequent state changes to L1. These submissions represent Checkpoint finality. The assets are not redeemable on L1 yet, but the data proving ownership of those assets are now on L1. This should give the user a much higher confidence in their assets\u2019 eventual redemption. At some point, the computational integrity of all those submitted L2 state transitions is verified on L1. Once that occurs, we have L1 finality and the user\u2019s assets are redeemable on L1. Programmability Programmability at the L2 layer is important. Programmability is the key feature of Ethereum. Transactions become a canvas for innovation compared to the more limited execution environment like Bitcoin\u2019s Script. L2 projects that reuse the Ethereum stack benefit from the collective investment into security, developer tools, community support and knowledge of stack, languages, gotchas and failure modes. Zero-knowledge proof (ZKP)-powered L2s are forcing innovation in the programmability arena. ZKP execution environments have traditionally been limited in their capacity due to the nature of their circuits. New zk-circuit-friendly languages are emerging (Gnark, Cairo, Zinc) and bringing greater programmability; however, they require new virtual machines with little proven track record and nascent community support. Extending programmability at the L2 layer will provide an opportunity to experiment with low-level innovation and EIP protocol-level changes like account abstraction, native meta-transaction, and different computation models or runtimes. Conclusion This was a very technical discussion of the rubric for analyzing L2 or scalability solutions. We hope it gives you a sense of the trade-offs each solution provides. If you'd like a less-technical approach to this same rubric, you can see the article below. Additional Material Article: For Questions to Judge Any Layer 2 Scaling Solution A less-technical, more general-audience article discussing the same paradigm outlined in this lesson","title":"Index"},{"location":"S08-scalability/M3-rubric/L1/#rubric-for-analyzing-scalability-solutions","text":"The challenge with understanding Layer 2 and scaling solutions is a common challenge for The explosion in demand for sophisticated, bleeding-edge cryptographic products leads to a common predicament in blockchain. For those not deeply familiar with these projects and their associated tech, it\u2019s extremely difficult\u2014if not intimidating\u2014to decide which is best and safest to use. Not to mention the rate of change of L2 documentation and the L2 frameworks themselves. However, there are trade-offs to using scalability solutions. Trade-offs to the blockchain primitives we discussed earlier in the course. With this section, we will continue propose a framework to assist the analysis of L2 projects. It\u2019s meant to help the reader develop an intuition for approaching a possible L2 solution for their various needs and circumstances. But it's also meant to highlight the trade-offs a scalability approach requires against our main blockchain network layer. This framework has eight assessment variables ( Operator , Data Availability , Computational Integrity , Economic Security , Stack Security , Capital Efficiency , Transaction Finality , and Programmability ). We use these assessment variables to score a project in three areas: Throughput , Security and Usability . See how the variables contribute to each area below: To be clear, these variables are not exhaustive. We haven\u2019t included network costs, users costs or the downstream network effects a Layer 2 inherits from the underlying Layer 1 blockchain. Again, the idea of the framework is not necessarily to be comprehensive but rather help develop an intuition for the benefits and trade-offs of different L2 solutions. Be sure to keep in mind the mental model around distributed consensus we learned earlier, it will come in handy. You can understand this lesson as a deeper development of the roles and features we discussed there.","title":"Rubric for Analyzing Scalability Solutions"},{"location":"S08-scalability/M3-rubric/L1/#l2-operator","text":"An Operator describes an actor within the L2 system responsible for executing state change within the L2 network. This includes facilitating entrances and exits to the L2 system as well as processing and authorizing transactions within the L2 system. Some considerations when analyzing an operator: - Is an Operator required in the L2 network? - Understanding Their Role: Who or what is the operator? What is the Operator responsible for? What is the motivation to become an Operator? - Trust Assumptions: Who can become an Operator? What power does an Operator have? What consensus rules do they abide by? What trust assumptions must users make about the Operator? - Risk Exposure: After answering the above questions, what risks do we need to consider? For example, how does the network respond when an Operator disappears, misbehaves. How does the system respond to L1 attacks or mass exit?","title":"L2 Operator"},{"location":"S08-scalability/M3-rubric/L1/#computational-integrity","text":"Computational Integrity (CI) is a key property of network security. CI seeks to ensure that the code for a given computation runs exactly as intended and therefore the state transition outputs are correct. Let\u2019s unpack this. The operation of each state advancement in a network can be simplified to: CI ensures that the data in the network is correct, because the code that advances the state of the network has run correctly and without manipulation by the operator actually performing the computation. It is enforced through two primary methods: Crypto-Economic Incentives This could take the form of incentivised consensus where the network can only advance if all network participants run and post the same computation resulting in a critical mass of agreement. It could also take the form of incentivised watchtowers where the network trusts third-parties to verify CI from operators and, in the case of misbehavior, trigger a network failsafe. Zero-Knowledge Cryptography Building mathematical assurances into the network\u2019s code execution model making integrity provable and verifiable","title":"Computational Integrity"},{"location":"S08-scalability/M3-rubric/L1/#data-availability","text":"This refers to the availability and immutability of intermediary state transition data. To go back to our state advancement of the network diagram: State transition data is a list of all intermediary state changes, alongside proof they are valid (e.g. aggregate signatures, ZKPs). Once a user\u2019s assets enter a L2, they are subject to the security properties of the L2, and therefore data availability is key to being able to verify that what happens to the user\u2019s assets within the L2 is valid and correct.","title":"Data Availability"},{"location":"S08-scalability/M3-rubric/L1/#economic-security","text":"Economic Security refers to the operational security that upholds the financial integrity of the L2 system. It can be rooted in two different areas: Inherited Economic Security from L1 This can be a strong inheritance where L2 assets are ultimately secured in contracts on L1 and L2 state transitions are checkpointed on L1. It can also be a weak inheritance, where L2 assets are ultimately secured on L1, but computational integrity and data availability are not secured by L1 Security Inherent to the Operator The characteristics of the L2 Operators may lend additional security, for example in Proof of Stake. Keep in mind, consensus methods such as Proof of Authority lend no inherent security beyond basic trust in the Operators.","title":"Economic Security"},{"location":"S08-scalability/M3-rubric/L1/#stack-security","text":"Stack Security is more of a passive security that comes from having a battle-hardened software stack. It includes aspects like: Shared Cryptographic Primitives Or primitives developed and hardened over decades of research and application. Compare this with newer cryptographic features that may not currently enjoy widespread adoption. For example, Elliptic Curve Cryptography versus newer ZKP methods. Shared Technology Stack Shared Investments into core technology stack and open-source network effects. Examples include the Go-Ethereum implementation, Solidity compiler and EVM runtime maintained by hundreds of contributors over time. Shared Ancillary Tooling Mature development environments and workflows, such as Truffle as well as security tooling, such as EVM bytecode formal verification, Solidity static analysis and fuzzers. Shared ecosystem and aligned security objectives The powerful network effects delivered by open-source development and the community that forms around it. Includes security gathered from audits, formal verification development, and institutional knowledge of attack vectors and history.","title":"Stack Security"},{"location":"S08-scalability/M3-rubric/L1/#capital-efficiency","text":"This refers to the cost and utility of capital held in an L2 network over time. L2 capital efficiency points that should be considered include: Capital must be locked into an L1 contract in order to move into the L2 Locking capital can come at high opportunity cost depending on the lockup times. Some systems require a lockup time of minutes, others require weeks. The real cost of capital can be discounted depending on the utility available within the network If the user can access great utility, the opportunity costs of lockup can be lower even if their capital is locked up. Fees for rapid exits, facilitated by liquidity providers (LPs), will be determined by real cost of capital. We'll discuss this more in our live session, \"Problems Still to Be Solved in Scalability.\"","title":"Capital Efficiency"},{"location":"S08-scalability/M3-rubric/L1/#transaction-finality","text":"Transaction finality on L1s is essentially full redeemability of assets. For L2s, there are multiple phases of finality: Operator finality, Checkpoint finality and L1 finality. The relationship of these three within a generic L2 is shown below: A user submitting a transaction within an L2 gets near-instantaneous finality when their transaction has been processed by an Operator. The user does not necessarily have to wait for L1 redeemability, rather they can use the Operator Finality as proof to exit via a Liquidity Provider. The Operator periodically submits a batch of L2 transactions and the subsequent state changes to L1. These submissions represent Checkpoint finality. The assets are not redeemable on L1 yet, but the data proving ownership of those assets are now on L1. This should give the user a much higher confidence in their assets\u2019 eventual redemption. At some point, the computational integrity of all those submitted L2 state transitions is verified on L1. Once that occurs, we have L1 finality and the user\u2019s assets are redeemable on L1.","title":"Transaction Finality"},{"location":"S08-scalability/M3-rubric/L1/#programmability","text":"Programmability at the L2 layer is important. Programmability is the key feature of Ethereum. Transactions become a canvas for innovation compared to the more limited execution environment like Bitcoin\u2019s Script. L2 projects that reuse the Ethereum stack benefit from the collective investment into security, developer tools, community support and knowledge of stack, languages, gotchas and failure modes. Zero-knowledge proof (ZKP)-powered L2s are forcing innovation in the programmability arena. ZKP execution environments have traditionally been limited in their capacity due to the nature of their circuits. New zk-circuit-friendly languages are emerging (Gnark, Cairo, Zinc) and bringing greater programmability; however, they require new virtual machines with little proven track record and nascent community support. Extending programmability at the L2 layer will provide an opportunity to experiment with low-level innovation and EIP protocol-level changes like account abstraction, native meta-transaction, and different computation models or runtimes.","title":"Programmability"},{"location":"S08-scalability/M3-rubric/L1/#conclusion","text":"This was a very technical discussion of the rubric for analyzing L2 or scalability solutions. We hope it gives you a sense of the trade-offs each solution provides. If you'd like a less-technical approach to this same rubric, you can see the article below.","title":"Conclusion"},{"location":"S08-scalability/M3-rubric/L1/#additional-material","text":"Article: For Questions to Judge Any Layer 2 Scaling Solution A less-technical, more general-audience article discussing the same paradigm outlined in this lesson","title":"Additional Material"},{"location":"S08-scalability/M5-crosschain/L1/","text":"From Peter Robinson: With regards Similarly, there is no one blockchain to rule them all. There are public permissionless blockchains such as Ethereum Mainnet, Bitcoin, and Filecoin. There are many instances of permissioned, consortium blockchains such as Enterprise Ethereum / Quorum, Corda and Hyperledger Fabric. Within the public permissionless Ethereum space, Sidechains and Roll-ups (L2s) are emerging to improve scalability. All of these technologies need Crosschain Communications to allow them to communicate. Even if the world settled on one blockchain technology platform, all data and all functionality is unlikely to reside on just one instance of the blockchain platform. Additional Material","title":"Index"},{"location":"S08-scalability/M5-crosschain/L1/#additional-material","text":"","title":"Additional Material"}]}